// Code generated by golang.org/x/tools/cmd/bundle.
//go:generate bundle -o h2_bundle.go -prefix xhttp2 golang.org/x/net/http2

// Package http2 implements the HTTP/2 protocol.
//
// This package is low-level and intended to be used directly by very
// few people. Most users will use it indirectly through the automatic
// use by the net/http package (from Go 1.6 and later).
// For use in earlier Go versions see ConfigureServer. (Transport support
// requires Go 1.6 or later)
//
// See https://http2.github.io/ for more information on HTTP/2.
//
// See https://http2.golang.org/ for a test server running this code.
//

package xhttp2

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"context"
	"crypto/rand"
	"crypto/tls"
	"encoding/binary"
	"errors"
	"fmt"
	"golang.org/x/net/http2/hpack"
	"golang.org/x/net/idna"
	"golang.org/x/net/lex/httplex"
	"io"
	"io/ioutil"
	"log"
	"math"
	"net"
	"net/http"
	"net/http/httptrace"
	"net/textproto"
	"net/url"
	"os"
	"reflect"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"
)

// ClientConnPool manages a pool of HTTP/2 client connections.
type xhttp2ClientConnPool interface {
	GetClientConn(req *http.Request, addr string) (*xhttp2ClientConn, error)
	MarkDead(*xhttp2ClientConn)
}

// clientConnPoolIdleCloser is the interface implemented by ClientConnPool
// implementations which can close their idle connections.
type xhttp2clientConnPoolIdleCloser interface {
	xhttp2ClientConnPool
	closeIdleConnections()
}

var (
	_ xhttp2clientConnPoolIdleCloser = (*xhttp2clientConnPool)(nil)
	_ xhttp2clientConnPoolIdleCloser = xhttp2noDialClientConnPool{}
)

// TODO: use singleflight for dialing and addConnCalls?
type xhttp2clientConnPool struct {
	t *xhttp2Transport

	mu sync.Mutex // TODO: maybe switch to RWMutex
	// TODO: add support for sharing conns based on cert names
	// (e.g. share conn for googleapis.com and appspot.com)
	conns        map[string][]*xhttp2ClientConn // key is host:port
	dialing      map[string]*xhttp2dialCall     // currently in-flight dials
	keys         map[*xhttp2ClientConn][]string
	addConnCalls map[string]*xhttp2addConnCall // in-flight addConnIfNeede calls
}

func (p *xhttp2clientConnPool) GetClientConn(req *http.Request, addr string) (*xhttp2ClientConn, error) {
	return p.getClientConn(req, addr, xhttp2dialOnMiss)
}

const (
	xhttp2dialOnMiss   = true
	xhttp2noDialOnMiss = false
)

func (p *xhttp2clientConnPool) getClientConn(req *http.Request, addr string, dialOnMiss bool) (*xhttp2ClientConn, error) {
	if xhttp2isConnectionCloseRequest(req) && dialOnMiss {
		// It gets its own connection.
		const singleUse = true
		cc, err := p.t.dialClientConn(addr, singleUse)
		if err != nil {
			return nil, err
		}
		return cc, nil
	}
	p.mu.Lock()
	for _, cc := range p.conns[addr] {
		if cc.CanTakeNewRequest() {
			p.mu.Unlock()
			return cc, nil
		}
	}
	if !dialOnMiss {
		p.mu.Unlock()
		return nil, xhttp2ErrNoCachedConn
	}
	call := p.getStartDialLocked(addr)
	p.mu.Unlock()
	<-call.done
	return call.res, call.err
}

// dialCall is an in-flight Transport dial call to a host.
type xhttp2dialCall struct {
	p    *xhttp2clientConnPool
	done chan struct{}     // closed when done
	res  *xhttp2ClientConn // valid after done is closed
	err  error             // valid after done is closed
}

// requires p.mu is held.
func (p *xhttp2clientConnPool) getStartDialLocked(addr string) *xhttp2dialCall {
	if call, ok := p.dialing[addr]; ok {

		return call
	}
	call := &xhttp2dialCall{p: p, done: make(chan struct{})}
	if p.dialing == nil {
		p.dialing = make(map[string]*xhttp2dialCall)
	}
	p.dialing[addr] = call
	go call.dial(addr)
	return call
}

// run in its own goroutine.
func (c *xhttp2dialCall) dial(addr string) {
	const singleUse = false // shared conn
	c.res, c.err = c.p.t.dialClientConn(addr, singleUse)
	close(c.done)

	c.p.mu.Lock()
	delete(c.p.dialing, addr)
	if c.err == nil {
		c.p.addConnLocked(addr, c.res)
	}
	c.p.mu.Unlock()
}

// addConnIfNeeded makes a NewClientConn out of c if a connection for key doesn't
// already exist. It coalesces concurrent calls with the same key.
// This is used by the http1 Transport code when it creates a new connection. Because
// the http1 Transport doesn't de-dup TCP dials to outbound hosts (because it doesn't know
// the protocol), it can get into a situation where it has multiple TLS connections.
// This code decides which ones live or die.
// The return value used is whether c was used.
// c is never closed.
func (p *xhttp2clientConnPool) addConnIfNeeded(key string, t *xhttp2Transport, c *tls.Conn) (used bool, err error) {
	p.mu.Lock()
	for _, cc := range p.conns[key] {
		if cc.CanTakeNewRequest() {
			p.mu.Unlock()
			return false, nil
		}
	}
	call, dup := p.addConnCalls[key]
	if !dup {
		if p.addConnCalls == nil {
			p.addConnCalls = make(map[string]*xhttp2addConnCall)
		}
		call = &xhttp2addConnCall{
			p:    p,
			done: make(chan struct{}),
		}
		p.addConnCalls[key] = call
		go call.run(t, key, c)
	}
	p.mu.Unlock()

	<-call.done
	if call.err != nil {
		return false, call.err
	}
	return !dup, nil
}

type xhttp2addConnCall struct {
	p    *xhttp2clientConnPool
	done chan struct{} // closed when done
	err  error
}

func (c *xhttp2addConnCall) run(t *xhttp2Transport, key string, tc *tls.Conn) {
	cc, err := t.NewClientConn(tc)

	p := c.p
	p.mu.Lock()
	if err != nil {
		c.err = err
	} else {
		p.addConnLocked(key, cc)
	}
	delete(p.addConnCalls, key)
	p.mu.Unlock()
	close(c.done)
}

func (p *xhttp2clientConnPool) addConn(key string, cc *xhttp2ClientConn) {
	p.mu.Lock()
	p.addConnLocked(key, cc)
	p.mu.Unlock()
}

// p.mu must be held
func (p *xhttp2clientConnPool) addConnLocked(key string, cc *xhttp2ClientConn) {
	for _, v := range p.conns[key] {
		if v == cc {
			return
		}
	}
	if p.conns == nil {
		p.conns = make(map[string][]*xhttp2ClientConn)
	}
	if p.keys == nil {
		p.keys = make(map[*xhttp2ClientConn][]string)
	}
	p.conns[key] = append(p.conns[key], cc)
	p.keys[cc] = append(p.keys[cc], key)
}

func (p *xhttp2clientConnPool) MarkDead(cc *xhttp2ClientConn) {
	p.mu.Lock()
	defer p.mu.Unlock()
	for _, key := range p.keys[cc] {
		vv, ok := p.conns[key]
		if !ok {
			continue
		}
		newList := xhttp2filterOutClientConn(vv, cc)
		if len(newList) > 0 {
			p.conns[key] = newList
		} else {
			delete(p.conns, key)
		}
	}
	delete(p.keys, cc)
}

func (p *xhttp2clientConnPool) closeIdleConnections() {
	p.mu.Lock()
	defer p.mu.Unlock()

	for _, vv := range p.conns {
		for _, cc := range vv {
			cc.closeIfIdle()
		}
	}
}

func xhttp2filterOutClientConn(in []*xhttp2ClientConn, exclude *xhttp2ClientConn) []*xhttp2ClientConn {
	out := in[:0]
	for _, v := range in {
		if v != exclude {
			out = append(out, v)
		}
	}

	if len(in) != len(out) {
		in[len(in)-1] = nil
	}
	return out
}

// noDialClientConnPool is an implementation of http2.ClientConnPool
// which never dials.  We let the HTTP/1.1 client dial and use its TLS
// connection instead.
type xhttp2noDialClientConnPool struct{ *xhttp2clientConnPool }

func (p xhttp2noDialClientConnPool) GetClientConn(req *http.Request, addr string) (*xhttp2ClientConn, error) {
	return p.getClientConn(req, addr, xhttp2noDialOnMiss)
}

func xhttp2configureTransport(t1 *http.Transport) (*xhttp2Transport, error) {
	connPool := new(xhttp2clientConnPool)
	t2 := &xhttp2Transport{
		ConnPool: xhttp2noDialClientConnPool{connPool},
		t1:       t1,
	}
	connPool.t = t2
	if err := xhttp2registerHTTPSProtocol(t1, xhttp2noDialH2RoundTripper{t2}); err != nil {
		return nil, err
	}
	if t1.TLSClientConfig == nil {
		t1.TLSClientConfig = new(tls.Config)
	}
	if !xhttp2strSliceContains(t1.TLSClientConfig.NextProtos, "h2") {
		t1.TLSClientConfig.NextProtos = append([]string{"h2"}, t1.TLSClientConfig.NextProtos...)
	}
	if !xhttp2strSliceContains(t1.TLSClientConfig.NextProtos, "http/1.1") {
		t1.TLSClientConfig.NextProtos = append(t1.TLSClientConfig.NextProtos, "http/1.1")
	}
	upgradeFn := func(authority string, c *tls.Conn) http.RoundTripper {
		addr := xhttp2authorityAddr("https", authority)
		if used, err := connPool.addConnIfNeeded(addr, t2, c); err != nil {
			go c.Close()
			return xhttp2erringRoundTripper{err}
		} else if !used {

			go c.Close()
		}
		return t2
	}
	if m := t1.TLSNextProto; len(m) == 0 {
		t1.TLSNextProto = map[string]func(string, *tls.Conn) http.RoundTripper{
			"h2": upgradeFn,
		}
	} else {
		m["h2"] = upgradeFn
	}
	return t2, nil
}

// registerHTTPSProtocol calls Transport.RegisterProtocol but
// convering panics into errors.
func xhttp2registerHTTPSProtocol(t *http.Transport, rt http.RoundTripper) (err error) {
	defer func() {
		if e := recover(); e != nil {
			err = fmt.Errorf("%v", e)
		}
	}()
	t.RegisterProtocol("https", rt)
	return nil
}

// noDialH2RoundTripper is a RoundTripper which only tries to complete the request
// if there's already has a cached connection to the host.
type xhttp2noDialH2RoundTripper struct{ t *xhttp2Transport }

func (rt xhttp2noDialH2RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	res, err := rt.t.RoundTrip(req)
	if err == xhttp2ErrNoCachedConn {
		return nil, http.ErrSkipAltProtocol
	}
	return res, err
}

// An ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec.
type xhttp2ErrCode uint32

const (
	xhttp2ErrCodeNo                 xhttp2ErrCode = 0x0
	xhttp2ErrCodeProtocol           xhttp2ErrCode = 0x1
	xhttp2ErrCodeInternal           xhttp2ErrCode = 0x2
	xhttp2ErrCodeFlowControl        xhttp2ErrCode = 0x3
	xhttp2ErrCodeSettingsTimeout    xhttp2ErrCode = 0x4
	xhttp2ErrCodeStreamClosed       xhttp2ErrCode = 0x5
	xhttp2ErrCodeFrameSize          xhttp2ErrCode = 0x6
	xhttp2ErrCodeRefusedStream      xhttp2ErrCode = 0x7
	xhttp2ErrCodeCancel             xhttp2ErrCode = 0x8
	xhttp2ErrCodeCompression        xhttp2ErrCode = 0x9
	xhttp2ErrCodeConnect            xhttp2ErrCode = 0xa
	xhttp2ErrCodeEnhanceYourCalm    xhttp2ErrCode = 0xb
	xhttp2ErrCodeInadequateSecurity xhttp2ErrCode = 0xc
	xhttp2ErrCodeHTTP11Required     xhttp2ErrCode = 0xd
)

var xhttp2errCodeName = map[xhttp2ErrCode]string{
	xhttp2ErrCodeNo:                 "NO_ERROR",
	xhttp2ErrCodeProtocol:           "PROTOCOL_ERROR",
	xhttp2ErrCodeInternal:           "INTERNAL_ERROR",
	xhttp2ErrCodeFlowControl:        "FLOW_CONTROL_ERROR",
	xhttp2ErrCodeSettingsTimeout:    "SETTINGS_TIMEOUT",
	xhttp2ErrCodeStreamClosed:       "STREAM_CLOSED",
	xhttp2ErrCodeFrameSize:          "FRAME_SIZE_ERROR",
	xhttp2ErrCodeRefusedStream:      "REFUSED_STREAM",
	xhttp2ErrCodeCancel:             "CANCEL",
	xhttp2ErrCodeCompression:        "COMPRESSION_ERROR",
	xhttp2ErrCodeConnect:            "CONNECT_ERROR",
	xhttp2ErrCodeEnhanceYourCalm:    "ENHANCE_YOUR_CALM",
	xhttp2ErrCodeInadequateSecurity: "INADEQUATE_SECURITY",
	xhttp2ErrCodeHTTP11Required:     "HTTP_1_1_REQUIRED",
}

func (e xhttp2ErrCode) String() string {
	if s, ok := xhttp2errCodeName[e]; ok {
		return s
	}
	return fmt.Sprintf("unknown error code 0x%x", uint32(e))
}

// ConnectionError is an error that results in the termination of the
// entire connection.
type xhttp2ConnectionError xhttp2ErrCode

func (e xhttp2ConnectionError) Error() string {
	return fmt.Sprintf("connection error: %s", xhttp2ErrCode(e))
}

// StreamError is an error that only affects one stream within an
// HTTP/2 connection.
type xhttp2StreamError struct {
	StreamID uint32
	Code     xhttp2ErrCode
	Cause    error // optional additional detail
}

func xhttp2streamError(id uint32, code xhttp2ErrCode) xhttp2StreamError {
	return xhttp2StreamError{StreamID: id, Code: code}
}

func (e xhttp2StreamError) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("stream error: stream ID %d; %v; %v", e.StreamID, e.Code, e.Cause)
	}
	return fmt.Sprintf("stream error: stream ID %d; %v", e.StreamID, e.Code)
}

// 6.9.1 The Flow Control Window
// "If a sender receives a WINDOW_UPDATE that causes a flow control
// window to exceed this maximum it MUST terminate either the stream
// or the connection, as appropriate. For streams, [...]; for the
// connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code."
type xhttp2goAwayFlowError struct{}

func (xhttp2goAwayFlowError) Error() string { return "connection exceeded flow control window size" }

// Errors of this type are only returned by the frame parser functions
// and converted into ConnectionError(ErrCodeProtocol).
type xhttp2connError struct {
	Code   xhttp2ErrCode
	Reason string
}

func (e xhttp2connError) Error() string {
	return fmt.Sprintf("http2: connection error: %v: %v", e.Code, e.Reason)
}

type xhttp2pseudoHeaderError string

func (e xhttp2pseudoHeaderError) Error() string {
	return fmt.Sprintf("invalid pseudo-header %q", string(e))
}

type xhttp2duplicatePseudoHeaderError string

func (e xhttp2duplicatePseudoHeaderError) Error() string {
	return fmt.Sprintf("duplicate pseudo-header %q", string(e))
}

type xhttp2headerFieldNameError string

func (e xhttp2headerFieldNameError) Error() string {
	return fmt.Sprintf("invalid header field name %q", string(e))
}

type xhttp2headerFieldValueError string

func (e xhttp2headerFieldValueError) Error() string {
	return fmt.Sprintf("invalid header field value %q", string(e))
}

var (
	xhttp2errMixPseudoHeaderTypes = errors.New("mix of request and response pseudo headers")
	xhttp2errPseudoAfterRegular   = errors.New("pseudo header field after regular")
)

// fixedBuffer is an io.ReadWriter backed by a fixed size buffer.
// It never allocates, but moves old data as new data is written.
type xhttp2fixedBuffer struct {
	buf  []byte
	r, w int
}

var (
	xhttp2errReadEmpty = errors.New("read from empty fixedBuffer")
	xhttp2errWriteFull = errors.New("write on full fixedBuffer")
)

// Read copies bytes from the buffer into p.
// It is an error to read when no data is available.
func (b *xhttp2fixedBuffer) Read(p []byte) (n int, err error) {
	if b.r == b.w {
		return 0, xhttp2errReadEmpty
	}
	n = copy(p, b.buf[b.r:b.w])
	b.r += n
	if b.r == b.w {
		b.r = 0
		b.w = 0
	}
	return n, nil
}

// Len returns the number of bytes of the unread portion of the buffer.
func (b *xhttp2fixedBuffer) Len() int {
	return b.w - b.r
}

// Write copies bytes from p into the buffer.
// It is an error to write more data than the buffer can hold.
func (b *xhttp2fixedBuffer) Write(p []byte) (n int, err error) {

	if b.r > 0 && len(p) > len(b.buf)-b.w {
		copy(b.buf, b.buf[b.r:b.w])
		b.w -= b.r
		b.r = 0
	}

	n = copy(b.buf[b.w:], p)
	b.w += n
	if n < len(p) {
		err = xhttp2errWriteFull
	}
	return n, err
}

// flow is the flow control window's size.
type xhttp2flow struct {
	// n is the number of DATA bytes we're allowed to send.
	// A flow is kept both on a conn and a per-stream.
	n int32

	// conn points to the shared connection-level flow that is
	// shared by all streams on that conn. It is nil for the flow
	// that's on the conn directly.
	conn *xhttp2flow
}

func (f *xhttp2flow) setConnFlow(cf *xhttp2flow) { f.conn = cf }

func (f *xhttp2flow) available() int32 {
	n := f.n
	if f.conn != nil && f.conn.n < n {
		n = f.conn.n
	}
	return n
}

func (f *xhttp2flow) take(n int32) {
	if n > f.available() {
		panic("internal error: took too much")
	}
	f.n -= n
	if f.conn != nil {
		f.conn.n -= n
	}
}

// add adds n bytes (positive or negative) to the flow control window.
// It returns false if the sum would exceed 2^31-1.
func (f *xhttp2flow) add(n int32) bool {
	remain := (1<<31 - 1) - f.n
	if n > remain {
		return false
	}
	f.n += n
	return true
}

const xhttp2frameHeaderLen = 9

var xhttp2padZeros = make([]byte, 255) // zeros for padding

// A FrameType is a registered frame type as defined in
// http://http2.github.io/http2-spec/#rfc.section.11.2
type xhttp2FrameType uint8

const (
	xhttp2FrameData         xhttp2FrameType = 0x0
	xhttp2FrameHeaders      xhttp2FrameType = 0x1
	xhttp2FramePriority     xhttp2FrameType = 0x2
	xhttp2FrameRSTStream    xhttp2FrameType = 0x3
	xhttp2FrameSettings     xhttp2FrameType = 0x4
	xhttp2FramePushPromise  xhttp2FrameType = 0x5
	xhttp2FramePing         xhttp2FrameType = 0x6
	xhttp2FrameGoAway       xhttp2FrameType = 0x7
	xhttp2FrameWindowUpdate xhttp2FrameType = 0x8
	xhttp2FrameContinuation xhttp2FrameType = 0x9
)

var xhttp2frameName = map[xhttp2FrameType]string{
	xhttp2FrameData:         "DATA",
	xhttp2FrameHeaders:      "HEADERS",
	xhttp2FramePriority:     "PRIORITY",
	xhttp2FrameRSTStream:    "RST_STREAM",
	xhttp2FrameSettings:     "SETTINGS",
	xhttp2FramePushPromise:  "PUSH_PROMISE",
	xhttp2FramePing:         "PING",
	xhttp2FrameGoAway:       "GOAWAY",
	xhttp2FrameWindowUpdate: "WINDOW_UPDATE",
	xhttp2FrameContinuation: "CONTINUATION",
}

func (t xhttp2FrameType) String() string {
	if s, ok := xhttp2frameName[t]; ok {
		return s
	}
	return fmt.Sprintf("UNKNOWN_FRAME_TYPE_%d", uint8(t))
}

// Flags is a bitmask of HTTP/2 flags.
// The meaning of flags varies depending on the frame type.
type xhttp2Flags uint8

// Has reports whether f contains all (0 or more) flags in v.
func (f xhttp2Flags) Has(v xhttp2Flags) bool {
	return (f & v) == v
}

// Frame-specific FrameHeader flag bits.
const (
	// Data Frame
	xhttp2FlagDataEndStream xhttp2Flags = 0x1
	xhttp2FlagDataPadded    xhttp2Flags = 0x8

	// Headers Frame
	xhttp2FlagHeadersEndStream  xhttp2Flags = 0x1
	xhttp2FlagHeadersEndHeaders xhttp2Flags = 0x4
	xhttp2FlagHeadersPadded     xhttp2Flags = 0x8
	xhttp2FlagHeadersPriority   xhttp2Flags = 0x20

	// Settings Frame
	xhttp2FlagSettingsAck xhttp2Flags = 0x1

	// Ping Frame
	xhttp2FlagPingAck xhttp2Flags = 0x1

	// Continuation Frame
	xhttp2FlagContinuationEndHeaders xhttp2Flags = 0x4

	xhttp2FlagPushPromiseEndHeaders xhttp2Flags = 0x4
	xhttp2FlagPushPromisePadded     xhttp2Flags = 0x8
)

var xhttp2flagName = map[xhttp2FrameType]map[xhttp2Flags]string{
	xhttp2FrameData: {
		xhttp2FlagDataEndStream: "END_STREAM",
		xhttp2FlagDataPadded:    "PADDED",
	},
	xhttp2FrameHeaders: {
		xhttp2FlagHeadersEndStream:  "END_STREAM",
		xhttp2FlagHeadersEndHeaders: "END_HEADERS",
		xhttp2FlagHeadersPadded:     "PADDED",
		xhttp2FlagHeadersPriority:   "PRIORITY",
	},
	xhttp2FrameSettings: {
		xhttp2FlagSettingsAck: "ACK",
	},
	xhttp2FramePing: {
		xhttp2FlagPingAck: "ACK",
	},
	xhttp2FrameContinuation: {
		xhttp2FlagContinuationEndHeaders: "END_HEADERS",
	},
	xhttp2FramePushPromise: {
		xhttp2FlagPushPromiseEndHeaders: "END_HEADERS",
		xhttp2FlagPushPromisePadded:     "PADDED",
	},
}

// a frameParser parses a frame given its FrameHeader and payload
// bytes. The length of payload will always equal fh.Length (which
// might be 0).
type xhttp2frameParser func(fh xhttp2FrameHeader, payload []byte) (xhttp2Frame, error)

var xhttp2frameParsers = map[xhttp2FrameType]xhttp2frameParser{
	xhttp2FrameData:         xhttp2parseDataFrame,
	xhttp2FrameHeaders:      xhttp2parseHeadersFrame,
	xhttp2FramePriority:     xhttp2parsePriorityFrame,
	xhttp2FrameRSTStream:    xhttp2parseRSTStreamFrame,
	xhttp2FrameSettings:     xhttp2parseSettingsFrame,
	xhttp2FramePushPromise:  xhttp2parsePushPromise,
	xhttp2FramePing:         xhttp2parsePingFrame,
	xhttp2FrameGoAway:       xhttp2parseGoAwayFrame,
	xhttp2FrameWindowUpdate: xhttp2parseWindowUpdateFrame,
	xhttp2FrameContinuation: xhttp2parseContinuationFrame,
}

func xhttp2typeFrameParser(t xhttp2FrameType) xhttp2frameParser {
	if f := xhttp2frameParsers[t]; f != nil {
		return f
	}
	return xhttp2parseUnknownFrame
}

// A FrameHeader is the 9 byte header of all HTTP/2 frames.
//
// See http://http2.github.io/http2-spec/#FrameHeader
type xhttp2FrameHeader struct {
	valid bool // caller can access []byte fields in the Frame

	// Type is the 1 byte frame type. There are ten standard frame
	// types, but extension frame types may be written by WriteRawFrame
	// and will be returned by ReadFrame (as UnknownFrame).
	Type xhttp2FrameType

	// Flags are the 1 byte of 8 potential bit flags per frame.
	// They are specific to the frame type.
	Flags xhttp2Flags

	// Length is the length of the frame, not including the 9 byte header.
	// The maximum size is one byte less than 16MB (uint24), but only
	// frames up to 16KB are allowed without peer agreement.
	Length uint32

	// StreamID is which stream this frame is for. Certain frames
	// are not stream-specific, in which case this field is 0.
	StreamID uint32
}

// Header returns h. It exists so FrameHeaders can be embedded in other
// specific frame types and implement the Frame interface.
func (h xhttp2FrameHeader) Header() xhttp2FrameHeader { return h }

func (h xhttp2FrameHeader) String() string {
	var buf bytes.Buffer
	buf.WriteString("[FrameHeader ")
	h.writeDebug(&buf)
	buf.WriteByte(']')
	return buf.String()
}

func (h xhttp2FrameHeader) writeDebug(buf *bytes.Buffer) {
	buf.WriteString(h.Type.String())
	if h.Flags != 0 {
		buf.WriteString(" flags=")
		set := 0
		for i := uint8(0); i < 8; i++ {
			if h.Flags&(1<<i) == 0 {
				continue
			}
			set++
			if set > 1 {
				buf.WriteByte('|')
			}
			name := xhttp2flagName[h.Type][xhttp2Flags(1<<i)]
			if name != "" {
				buf.WriteString(name)
			} else {
				fmt.Fprintf(buf, "0x%x", 1<<i)
			}
		}
	}
	if h.StreamID != 0 {
		fmt.Fprintf(buf, " stream=%d", h.StreamID)
	}
	fmt.Fprintf(buf, " len=%d", h.Length)
}

func (h *xhttp2FrameHeader) checkValid() {
	if !h.valid {
		panic("Frame accessor called on non-owned Frame")
	}
}

func (h *xhttp2FrameHeader) invalidate() { h.valid = false }

// frame header bytes.
// Used only by ReadFrameHeader.
var xhttp2fhBytes = sync.Pool{
	New: func() interface{} {
		buf := make([]byte, xhttp2frameHeaderLen)
		return &buf
	},
}

// ReadFrameHeader reads 9 bytes from r and returns a FrameHeader.
// Most users should use Framer.ReadFrame instead.
func xhttp2ReadFrameHeader(r io.Reader) (xhttp2FrameHeader, error) {
	bufp := xhttp2fhBytes.Get().(*[]byte)
	defer xhttp2fhBytes.Put(bufp)
	return xhttp2readFrameHeader(*bufp, r)
}

func xhttp2readFrameHeader(buf []byte, r io.Reader) (xhttp2FrameHeader, error) {
	_, err := io.ReadFull(r, buf[:xhttp2frameHeaderLen])
	if err != nil {
		return xhttp2FrameHeader{}, err
	}
	return xhttp2FrameHeader{
		Length:   (uint32(buf[0])<<16 | uint32(buf[1])<<8 | uint32(buf[2])),
		Type:     xhttp2FrameType(buf[3]),
		Flags:    xhttp2Flags(buf[4]),
		StreamID: binary.BigEndian.Uint32(buf[5:]) & (1<<31 - 1),
		valid:    true,
	}, nil
}

// A Frame is the base interface implemented by all frame types.
// Callers will generally type-assert the specific frame type:
// *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.
//
// Frames are only valid until the next call to Framer.ReadFrame.
type xhttp2Frame interface {
	Header() xhttp2FrameHeader

	// invalidate is called by Framer.ReadFrame to make this
	// frame's buffers as being invalid, since the subsequent
	// frame will reuse them.
	invalidate()
}

// A Framer reads and writes Frames.
type xhttp2Framer struct {
	r         io.Reader
	lastFrame xhttp2Frame
	errDetail error

	// lastHeaderStream is non-zero if the last frame was an
	// unfinished HEADERS/CONTINUATION.
	lastHeaderStream uint32

	maxReadSize uint32
	headerBuf   [xhttp2frameHeaderLen]byte

	// TODO: let getReadBuf be configurable, and use a less memory-pinning
	// allocator in server.go to minimize memory pinned for many idle conns.
	// Will probably also need to make frame invalidation have a hook too.
	getReadBuf func(size uint32) []byte
	readBuf    []byte // cache for default getReadBuf

	maxWriteSize uint32 // zero means unlimited; TODO: implement

	w    io.Writer
	wbuf []byte

	// AllowIllegalWrites permits the Framer's Write methods to
	// write frames that do not conform to the HTTP/2 spec. This
	// permits using the Framer to test other HTTP/2
	// implementations' conformance to the spec.
	// If false, the Write methods will prefer to return an error
	// rather than comply.
	AllowIllegalWrites bool

	// AllowIllegalReads permits the Framer's ReadFrame method
	// to return non-compliant frames or frame orders.
	// This is for testing and permits using the Framer to test
	// other HTTP/2 implementations' conformance to the spec.
	// It is not compatible with ReadMetaHeaders.
	AllowIllegalReads bool

	// ReadMetaHeaders if non-nil causes ReadFrame to merge
	// HEADERS and CONTINUATION frames together and return
	// MetaHeadersFrame instead.
	ReadMetaHeaders *hpack.Decoder

	// MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.
	// It's used only if ReadMetaHeaders is set; 0 means a sane default
	// (currently 16MB)
	// If the limit is hit, MetaHeadersFrame.Truncated is set true.
	MaxHeaderListSize uint32

	logReads, logWrites bool

	debugFramer       *xhttp2Framer // only use for logging written writes
	debugFramerBuf    *bytes.Buffer
	debugReadLoggerf  func(string, ...interface{})
	debugWriteLoggerf func(string, ...interface{})
}

func (fr *xhttp2Framer) maxHeaderListSize() uint32 {
	if fr.MaxHeaderListSize == 0 {
		return 16 << 20
	}
	return fr.MaxHeaderListSize
}

func (f *xhttp2Framer) startWrite(ftype xhttp2FrameType, flags xhttp2Flags, streamID uint32) {

	f.wbuf = append(f.wbuf[:0],
		0,
		0,
		0,
		byte(ftype),
		byte(flags),
		byte(streamID>>24),
		byte(streamID>>16),
		byte(streamID>>8),
		byte(streamID))
}

func (f *xhttp2Framer) endWrite() error {

	length := len(f.wbuf) - xhttp2frameHeaderLen
	if length >= (1 << 24) {
		return xhttp2ErrFrameTooLarge
	}
	_ = append(f.wbuf[:0],
		byte(length>>16),
		byte(length>>8),
		byte(length))
	if f.logWrites {
		f.logWrite()
	}

	n, err := f.w.Write(f.wbuf)
	if err == nil && n != len(f.wbuf) {
		err = io.ErrShortWrite
	}
	return err
}

func (f *xhttp2Framer) logWrite() {
	if f.debugFramer == nil {
		f.debugFramerBuf = new(bytes.Buffer)
		f.debugFramer = xhttp2NewFramer(nil, f.debugFramerBuf)
		f.debugFramer.logReads = false

		f.debugFramer.AllowIllegalReads = true
	}
	f.debugFramerBuf.Write(f.wbuf)
	fr, err := f.debugFramer.ReadFrame()
	if err != nil {
		f.debugWriteLoggerf("http2: Framer %p: failed to decode just-written frame", f)
		return
	}
	f.debugWriteLoggerf("http2: Framer %p: wrote %v", f, xhttp2summarizeFrame(fr))
}

func (f *xhttp2Framer) writeByte(v byte) { f.wbuf = append(f.wbuf, v) }

func (f *xhttp2Framer) writeBytes(v []byte) { f.wbuf = append(f.wbuf, v...) }

func (f *xhttp2Framer) writeUint16(v uint16) { f.wbuf = append(f.wbuf, byte(v>>8), byte(v)) }

func (f *xhttp2Framer) writeUint32(v uint32) {
	f.wbuf = append(f.wbuf, byte(v>>24), byte(v>>16), byte(v>>8), byte(v))
}

const (
	xhttp2minMaxFrameSize = 1 << 14
	xhttp2maxFrameSize    = 1<<24 - 1
)

// NewFramer returns a Framer that writes frames to w and reads them from r.
func xhttp2NewFramer(w io.Writer, r io.Reader) *xhttp2Framer {
	fr := &xhttp2Framer{
		w:                 w,
		r:                 r,
		logReads:          xhttp2logFrameReads,
		logWrites:         xhttp2logFrameWrites,
		debugReadLoggerf:  log.Printf,
		debugWriteLoggerf: log.Printf,
	}
	fr.getReadBuf = func(size uint32) []byte {
		if cap(fr.readBuf) >= int(size) {
			return fr.readBuf[:size]
		}
		fr.readBuf = make([]byte, size)
		return fr.readBuf
	}
	fr.SetMaxReadFrameSize(xhttp2maxFrameSize)
	return fr
}

// SetMaxReadFrameSize sets the maximum size of a frame
// that will be read by a subsequent call to ReadFrame.
// It is the caller's responsibility to advertise this
// limit with a SETTINGS frame.
func (fr *xhttp2Framer) SetMaxReadFrameSize(v uint32) {
	if v > xhttp2maxFrameSize {
		v = xhttp2maxFrameSize
	}
	fr.maxReadSize = v
}

// ErrorDetail returns a more detailed error of the last error
// returned by Framer.ReadFrame. For instance, if ReadFrame
// returns a StreamError with code PROTOCOL_ERROR, ErrorDetail
// will say exactly what was invalid. ErrorDetail is not guaranteed
// to return a non-nil value and like the rest of the http2 package,
// its return value is not protected by an API compatibility promise.
// ErrorDetail is reset after the next call to ReadFrame.
func (fr *xhttp2Framer) ErrorDetail() error {
	return fr.errDetail
}

// ErrFrameTooLarge is returned from Framer.ReadFrame when the peer
// sends a frame that is larger than declared with SetMaxReadFrameSize.
var xhttp2ErrFrameTooLarge = errors.New("http2: frame too large")

// terminalReadFrameError reports whether err is an unrecoverable
// error from ReadFrame and no other frames should be read.
func xhttp2terminalReadFrameError(err error) bool {
	if _, ok := err.(xhttp2StreamError); ok {
		return false
	}
	return err != nil
}

// ReadFrame reads a single frame. The returned Frame is only valid
// until the next call to ReadFrame.
//
// If the frame is larger than previously set with SetMaxReadFrameSize, the
// returned error is ErrFrameTooLarge. Other errors may be of type
// ConnectionError, StreamError, or anything else from the underlying
// reader.
func (fr *xhttp2Framer) ReadFrame() (xhttp2Frame, error) {
	fr.errDetail = nil
	if fr.lastFrame != nil {
		fr.lastFrame.invalidate()
	}
	fh, err := xhttp2readFrameHeader(fr.headerBuf[:], fr.r)
	if err != nil {
		return nil, err
	}
	if fh.Length > fr.maxReadSize {
		return nil, xhttp2ErrFrameTooLarge
	}
	payload := fr.getReadBuf(fh.Length)
	if _, err := io.ReadFull(fr.r, payload); err != nil {
		return nil, err
	}
	f, err := xhttp2typeFrameParser(fh.Type)(fh, payload)
	if err != nil {
		if ce, ok := err.(xhttp2connError); ok {
			return nil, fr.connError(ce.Code, ce.Reason)
		}
		return nil, err
	}
	if err := fr.checkFrameOrder(f); err != nil {
		return nil, err
	}
	if fr.logReads {
		fr.debugReadLoggerf("http2: Framer %p: read %v", fr, xhttp2summarizeFrame(f))
	}
	if fh.Type == xhttp2FrameHeaders && fr.ReadMetaHeaders != nil {
		return fr.readMetaFrame(f.(*xhttp2HeadersFrame))
	}
	return f, nil
}

// connError returns ConnectionError(code) but first
// stashes away a public reason to the caller can optionally relay it
// to the peer before hanging up on them. This might help others debug
// their implementations.
func (fr *xhttp2Framer) connError(code xhttp2ErrCode, reason string) error {
	fr.errDetail = errors.New(reason)
	return xhttp2ConnectionError(code)
}

// checkFrameOrder reports an error if f is an invalid frame to return
// next from ReadFrame. Mostly it checks whether HEADERS and
// CONTINUATION frames are contiguous.
func (fr *xhttp2Framer) checkFrameOrder(f xhttp2Frame) error {
	last := fr.lastFrame
	fr.lastFrame = f
	if fr.AllowIllegalReads {
		return nil
	}

	fh := f.Header()
	if fr.lastHeaderStream != 0 {
		if fh.Type != xhttp2FrameContinuation {
			return fr.connError(xhttp2ErrCodeProtocol,
				fmt.Sprintf("got %s for stream %d; expected CONTINUATION following %s for stream %d",
					fh.Type, fh.StreamID,
					last.Header().Type, fr.lastHeaderStream))
		}
		if fh.StreamID != fr.lastHeaderStream {
			return fr.connError(xhttp2ErrCodeProtocol,
				fmt.Sprintf("got CONTINUATION for stream %d; expected stream %d",
					fh.StreamID, fr.lastHeaderStream))
		}
	} else if fh.Type == xhttp2FrameContinuation {
		return fr.connError(xhttp2ErrCodeProtocol, fmt.Sprintf("unexpected CONTINUATION for stream %d", fh.StreamID))
	}

	switch fh.Type {
	case xhttp2FrameHeaders, xhttp2FrameContinuation:
		if fh.Flags.Has(xhttp2FlagHeadersEndHeaders) {
			fr.lastHeaderStream = 0
		} else {
			fr.lastHeaderStream = fh.StreamID
		}
	}

	return nil
}

// A DataFrame conveys arbitrary, variable-length sequences of octets
// associated with a stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.1
type xhttp2DataFrame struct {
	xhttp2FrameHeader
	data []byte
}

func (f *xhttp2DataFrame) StreamEnded() bool {
	return f.xhttp2FrameHeader.Flags.Has(xhttp2FlagDataEndStream)
}

// Data returns the frame's data octets, not including any padding
// size byte or padding suffix bytes.
// The caller must not retain the returned memory past the next
// call to ReadFrame.
func (f *xhttp2DataFrame) Data() []byte {
	f.checkValid()
	return f.data
}

func xhttp2parseDataFrame(fh xhttp2FrameHeader, payload []byte) (xhttp2Frame, error) {
	if fh.StreamID == 0 {

		return nil, xhttp2connError{xhttp2ErrCodeProtocol, "DATA frame with stream ID 0"}
	}
	f := &xhttp2DataFrame{
		xhttp2FrameHeader: fh,
	}
	var padSize byte
	if fh.Flags.Has(xhttp2FlagDataPadded) {
		var err error
		payload, padSize, err = xhttp2readByte(payload)
		if err != nil {
			return nil, err
		}
	}
	if int(padSize) > len(payload) {

		return nil, xhttp2connError{xhttp2ErrCodeProtocol, "pad size larger than data payload"}
	}
	f.data = payload[:len(payload)-int(padSize)]
	return f, nil
}

var (
	xhttp2errStreamID    = errors.New("invalid stream ID")
	xhttp2errDepStreamID = errors.New("invalid dependent stream ID")
	xhttp2errPadLength   = errors.New("pad length too large")
)

func xhttp2validStreamIDOrZero(streamID uint32) bool {
	return streamID&(1<<31) == 0
}

func xhttp2validStreamID(streamID uint32) bool {
	return streamID != 0 && streamID&(1<<31) == 0
}

// WriteData writes a DATA frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility not to violate the maximum frame size
// and to not call other Write methods concurrently.
func (f *xhttp2Framer) WriteData(streamID uint32, endStream bool, data []byte) error {
	return f.WriteDataPadded(streamID, endStream, data, nil)
}

// WriteData writes a DATA frame with optional padding.
//
// If pad is nil, the padding bit is not sent.
// The length of pad must not exceed 255 bytes.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility not to violate the maximum frame size
// and to not call other Write methods concurrently.
func (f *xhttp2Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error {
	if !xhttp2validStreamID(streamID) && !f.AllowIllegalWrites {
		return xhttp2errStreamID
	}
	if len(pad) > 255 {
		return xhttp2errPadLength
	}
	var flags xhttp2Flags
	if endStream {
		flags |= xhttp2FlagDataEndStream
	}
	if pad != nil {
		flags |= xhttp2FlagDataPadded
	}
	f.startWrite(xhttp2FrameData, flags, streamID)
	if pad != nil {
		f.wbuf = append(f.wbuf, byte(len(pad)))
	}
	f.wbuf = append(f.wbuf, data...)
	f.wbuf = append(f.wbuf, pad...)
	return f.endWrite()
}

// A SettingsFrame conveys configuration parameters that affect how
// endpoints communicate, such as preferences and constraints on peer
// behavior.
//
// See http://http2.github.io/http2-spec/#SETTINGS
type xhttp2SettingsFrame struct {
	xhttp2FrameHeader
	p []byte
}

func xhttp2parseSettingsFrame(fh xhttp2FrameHeader, p []byte) (xhttp2Frame, error) {
	if fh.Flags.Has(xhttp2FlagSettingsAck) && fh.Length > 0 {

		return nil, xhttp2ConnectionError(xhttp2ErrCodeFrameSize)
	}
	if fh.StreamID != 0 {

		return nil, xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	if len(p)%6 != 0 {

		return nil, xhttp2ConnectionError(xhttp2ErrCodeFrameSize)
	}
	f := &xhttp2SettingsFrame{xhttp2FrameHeader: fh, p: p}
	if v, ok := f.Value(xhttp2SettingInitialWindowSize); ok && v > (1<<31)-1 {

		return nil, xhttp2ConnectionError(xhttp2ErrCodeFlowControl)
	}
	return f, nil
}

func (f *xhttp2SettingsFrame) IsAck() bool {
	return f.xhttp2FrameHeader.Flags.Has(xhttp2FlagSettingsAck)
}

func (f *xhttp2SettingsFrame) Value(s xhttp2SettingID) (v uint32, ok bool) {
	f.checkValid()
	buf := f.p
	for len(buf) > 0 {
		settingID := xhttp2SettingID(binary.BigEndian.Uint16(buf[:2]))
		if settingID == s {
			return binary.BigEndian.Uint32(buf[2:6]), true
		}
		buf = buf[6:]
	}
	return 0, false
}

// ForeachSetting runs fn for each setting.
// It stops and returns the first error.
func (f *xhttp2SettingsFrame) ForeachSetting(fn func(xhttp2Setting) error) error {
	f.checkValid()
	buf := f.p
	for len(buf) > 0 {
		if err := fn(xhttp2Setting{
			xhttp2SettingID(binary.BigEndian.Uint16(buf[:2])),
			binary.BigEndian.Uint32(buf[2:6]),
		}); err != nil {
			return err
		}
		buf = buf[6:]
	}
	return nil
}

// WriteSettings writes a SETTINGS frame with zero or more settings
// specified and the ACK bit not set.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *xhttp2Framer) WriteSettings(settings ...xhttp2Setting) error {
	f.startWrite(xhttp2FrameSettings, 0, 0)
	for _, s := range settings {
		f.writeUint16(uint16(s.ID))
		f.writeUint32(s.Val)
	}
	return f.endWrite()
}

// WriteSettingsAck writes an empty SETTINGS frame with the ACK bit set.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *xhttp2Framer) WriteSettingsAck() error {
	f.startWrite(xhttp2FrameSettings, xhttp2FlagSettingsAck, 0)
	return f.endWrite()
}

// A PingFrame is a mechanism for measuring a minimal round trip time
// from the sender, as well as determining whether an idle connection
// is still functional.
// See http://http2.github.io/http2-spec/#rfc.section.6.7
type xhttp2PingFrame struct {
	xhttp2FrameHeader
	Data [8]byte
}

func (f *xhttp2PingFrame) IsAck() bool { return f.Flags.Has(xhttp2FlagPingAck) }

func xhttp2parsePingFrame(fh xhttp2FrameHeader, payload []byte) (xhttp2Frame, error) {
	if len(payload) != 8 {
		return nil, xhttp2ConnectionError(xhttp2ErrCodeFrameSize)
	}
	if fh.StreamID != 0 {
		return nil, xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	f := &xhttp2PingFrame{xhttp2FrameHeader: fh}
	copy(f.Data[:], payload)
	return f, nil
}

func (f *xhttp2Framer) WritePing(ack bool, data [8]byte) error {
	var flags xhttp2Flags
	if ack {
		flags = xhttp2FlagPingAck
	}
	f.startWrite(xhttp2FramePing, flags, 0)
	f.writeBytes(data[:])
	return f.endWrite()
}

// A GoAwayFrame informs the remote peer to stop creating streams on this connection.
// See http://http2.github.io/http2-spec/#rfc.section.6.8
type xhttp2GoAwayFrame struct {
	xhttp2FrameHeader
	LastStreamID uint32
	ErrCode      xhttp2ErrCode
	debugData    []byte
}

// DebugData returns any debug data in the GOAWAY frame. Its contents
// are not defined.
// The caller must not retain the returned memory past the next
// call to ReadFrame.
func (f *xhttp2GoAwayFrame) DebugData() []byte {
	f.checkValid()
	return f.debugData
}

func xhttp2parseGoAwayFrame(fh xhttp2FrameHeader, p []byte) (xhttp2Frame, error) {
	if fh.StreamID != 0 {
		return nil, xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	if len(p) < 8 {
		return nil, xhttp2ConnectionError(xhttp2ErrCodeFrameSize)
	}
	return &xhttp2GoAwayFrame{
		xhttp2FrameHeader: fh,
		LastStreamID:      binary.BigEndian.Uint32(p[:4]) & (1<<31 - 1),
		ErrCode:           xhttp2ErrCode(binary.BigEndian.Uint32(p[4:8])),
		debugData:         p[8:],
	}, nil
}

func (f *xhttp2Framer) WriteGoAway(maxStreamID uint32, code xhttp2ErrCode, debugData []byte) error {
	f.startWrite(xhttp2FrameGoAway, 0, 0)
	f.writeUint32(maxStreamID & (1<<31 - 1))
	f.writeUint32(uint32(code))
	f.writeBytes(debugData)
	return f.endWrite()
}

// An UnknownFrame is the frame type returned when the frame type is unknown
// or no specific frame type parser exists.
type xhttp2UnknownFrame struct {
	xhttp2FrameHeader
	p []byte
}

// Payload returns the frame's payload (after the header).  It is not
// valid to call this method after a subsequent call to
// Framer.ReadFrame, nor is it valid to retain the returned slice.
// The memory is owned by the Framer and is invalidated when the next
// frame is read.
func (f *xhttp2UnknownFrame) Payload() []byte {
	f.checkValid()
	return f.p
}

func xhttp2parseUnknownFrame(fh xhttp2FrameHeader, p []byte) (xhttp2Frame, error) {
	return &xhttp2UnknownFrame{fh, p}, nil
}

// A WindowUpdateFrame is used to implement flow control.
// See http://http2.github.io/http2-spec/#rfc.section.6.9
type xhttp2WindowUpdateFrame struct {
	xhttp2FrameHeader
	Increment uint32 // never read with high bit set
}

func xhttp2parseWindowUpdateFrame(fh xhttp2FrameHeader, p []byte) (xhttp2Frame, error) {
	if len(p) != 4 {
		return nil, xhttp2ConnectionError(xhttp2ErrCodeFrameSize)
	}
	inc := binary.BigEndian.Uint32(p[:4]) & 0x7fffffff
	if inc == 0 {

		if fh.StreamID == 0 {
			return nil, xhttp2ConnectionError(xhttp2ErrCodeProtocol)
		}
		return nil, xhttp2streamError(fh.StreamID, xhttp2ErrCodeProtocol)
	}
	return &xhttp2WindowUpdateFrame{
		xhttp2FrameHeader: fh,
		Increment:         inc,
	}, nil
}

// WriteWindowUpdate writes a WINDOW_UPDATE frame.
// The increment value must be between 1 and 2,147,483,647, inclusive.
// If the Stream ID is zero, the window update applies to the
// connection as a whole.
func (f *xhttp2Framer) WriteWindowUpdate(streamID, incr uint32) error {

	if (incr < 1 || incr > 2147483647) && !f.AllowIllegalWrites {
		return errors.New("illegal window increment value")
	}
	f.startWrite(xhttp2FrameWindowUpdate, 0, streamID)
	f.writeUint32(incr)
	return f.endWrite()
}

// A HeadersFrame is used to open a stream and additionally carries a
// header block fragment.
type xhttp2HeadersFrame struct {
	xhttp2FrameHeader

	// Priority is set if FlagHeadersPriority is set in the FrameHeader.
	Priority xhttp2PriorityParam

	headerFragBuf []byte // not owned
}

func (f *xhttp2HeadersFrame) HeaderBlockFragment() []byte {
	f.checkValid()
	return f.headerFragBuf
}

func (f *xhttp2HeadersFrame) HeadersEnded() bool {
	return f.xhttp2FrameHeader.Flags.Has(xhttp2FlagHeadersEndHeaders)
}

func (f *xhttp2HeadersFrame) StreamEnded() bool {
	return f.xhttp2FrameHeader.Flags.Has(xhttp2FlagHeadersEndStream)
}

func (f *xhttp2HeadersFrame) HasPriority() bool {
	return f.xhttp2FrameHeader.Flags.Has(xhttp2FlagHeadersPriority)
}

func xhttp2parseHeadersFrame(fh xhttp2FrameHeader, p []byte) (_ xhttp2Frame, err error) {
	hf := &xhttp2HeadersFrame{
		xhttp2FrameHeader: fh,
	}
	if fh.StreamID == 0 {

		return nil, xhttp2connError{xhttp2ErrCodeProtocol, "HEADERS frame with stream ID 0"}
	}
	var padLength uint8
	if fh.Flags.Has(xhttp2FlagHeadersPadded) {
		if p, padLength, err = xhttp2readByte(p); err != nil {
			return
		}
	}
	if fh.Flags.Has(xhttp2FlagHeadersPriority) {
		var v uint32
		p, v, err = xhttp2readUint32(p)
		if err != nil {
			return nil, err
		}
		hf.Priority.StreamDep = v & 0x7fffffff
		hf.Priority.Exclusive = (v != hf.Priority.StreamDep)
		p, hf.Priority.Weight, err = xhttp2readByte(p)
		if err != nil {
			return nil, err
		}
	}
	if len(p)-int(padLength) <= 0 {
		return nil, xhttp2streamError(fh.StreamID, xhttp2ErrCodeProtocol)
	}
	hf.headerFragBuf = p[:len(p)-int(padLength)]
	return hf, nil
}

// HeadersFrameParam are the parameters for writing a HEADERS frame.
type xhttp2HeadersFrameParam struct {
	// StreamID is the required Stream ID to initiate.
	StreamID uint32
	// BlockFragment is part (or all) of a Header Block.
	BlockFragment []byte

	// EndStream indicates that the header block is the last that
	// the endpoint will send for the identified stream. Setting
	// this flag causes the stream to enter one of "half closed"
	// states.
	EndStream bool

	// EndHeaders indicates that this frame contains an entire
	// header block and is not followed by any
	// CONTINUATION frames.
	EndHeaders bool

	// PadLength is the optional number of bytes of zeros to add
	// to this frame.
	PadLength uint8

	// Priority, if non-zero, includes stream priority information
	// in the HEADER frame.
	Priority xhttp2PriorityParam
}

// WriteHeaders writes a single HEADERS frame.
//
// This is a low-level header writing method. Encoding headers and
// splitting them into any necessary CONTINUATION frames is handled
// elsewhere.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *xhttp2Framer) WriteHeaders(p xhttp2HeadersFrameParam) error {
	if !xhttp2validStreamID(p.StreamID) && !f.AllowIllegalWrites {
		return xhttp2errStreamID
	}
	var flags xhttp2Flags
	if p.PadLength != 0 {
		flags |= xhttp2FlagHeadersPadded
	}
	if p.EndStream {
		flags |= xhttp2FlagHeadersEndStream
	}
	if p.EndHeaders {
		flags |= xhttp2FlagHeadersEndHeaders
	}
	if !p.Priority.IsZero() {
		flags |= xhttp2FlagHeadersPriority
	}
	f.startWrite(xhttp2FrameHeaders, flags, p.StreamID)
	if p.PadLength != 0 {
		f.writeByte(p.PadLength)
	}
	if !p.Priority.IsZero() {
		v := p.Priority.StreamDep
		if !xhttp2validStreamIDOrZero(v) && !f.AllowIllegalWrites {
			return xhttp2errDepStreamID
		}
		if p.Priority.Exclusive {
			v |= 1 << 31
		}
		f.writeUint32(v)
		f.writeByte(p.Priority.Weight)
	}
	f.wbuf = append(f.wbuf, p.BlockFragment...)
	f.wbuf = append(f.wbuf, xhttp2padZeros[:p.PadLength]...)
	return f.endWrite()
}

// A PriorityFrame specifies the sender-advised priority of a stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.3
type xhttp2PriorityFrame struct {
	xhttp2FrameHeader
	xhttp2PriorityParam
}

// PriorityParam are the stream prioritzation parameters.
type xhttp2PriorityParam struct {
	// StreamDep is a 31-bit stream identifier for the
	// stream that this stream depends on. Zero means no
	// dependency.
	StreamDep uint32

	// Exclusive is whether the dependency is exclusive.
	Exclusive bool

	// Weight is the stream's zero-indexed weight. It should be
	// set together with StreamDep, or neither should be set.  Per
	// the spec, "Add one to the value to obtain a weight between
	// 1 and 256."
	Weight uint8
}

func (p xhttp2PriorityParam) IsZero() bool {
	return p == xhttp2PriorityParam{}
}

func xhttp2parsePriorityFrame(fh xhttp2FrameHeader, payload []byte) (xhttp2Frame, error) {
	if fh.StreamID == 0 {
		return nil, xhttp2connError{xhttp2ErrCodeProtocol, "PRIORITY frame with stream ID 0"}
	}
	if len(payload) != 5 {
		return nil, xhttp2connError{xhttp2ErrCodeFrameSize, fmt.Sprintf("PRIORITY frame payload size was %d; want 5", len(payload))}
	}
	v := binary.BigEndian.Uint32(payload[:4])
	streamID := v & 0x7fffffff
	return &xhttp2PriorityFrame{
		xhttp2FrameHeader: fh,
		xhttp2PriorityParam: xhttp2PriorityParam{
			Weight:    payload[4],
			StreamDep: streamID,
			Exclusive: streamID != v,
		},
	}, nil
}

// WritePriority writes a PRIORITY frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *xhttp2Framer) WritePriority(streamID uint32, p xhttp2PriorityParam) error {
	if !xhttp2validStreamID(streamID) && !f.AllowIllegalWrites {
		return xhttp2errStreamID
	}
	if !xhttp2validStreamIDOrZero(p.StreamDep) {
		return xhttp2errDepStreamID
	}
	f.startWrite(xhttp2FramePriority, 0, streamID)
	v := p.StreamDep
	if p.Exclusive {
		v |= 1 << 31
	}
	f.writeUint32(v)
	f.writeByte(p.Weight)
	return f.endWrite()
}

// A RSTStreamFrame allows for abnormal termination of a stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.4
type xhttp2RSTStreamFrame struct {
	xhttp2FrameHeader
	ErrCode xhttp2ErrCode
}

func xhttp2parseRSTStreamFrame(fh xhttp2FrameHeader, p []byte) (xhttp2Frame, error) {
	if len(p) != 4 {
		return nil, xhttp2ConnectionError(xhttp2ErrCodeFrameSize)
	}
	if fh.StreamID == 0 {
		return nil, xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	return &xhttp2RSTStreamFrame{fh, xhttp2ErrCode(binary.BigEndian.Uint32(p[:4]))}, nil
}

// WriteRSTStream writes a RST_STREAM frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *xhttp2Framer) WriteRSTStream(streamID uint32, code xhttp2ErrCode) error {
	if !xhttp2validStreamID(streamID) && !f.AllowIllegalWrites {
		return xhttp2errStreamID
	}
	f.startWrite(xhttp2FrameRSTStream, 0, streamID)
	f.writeUint32(uint32(code))
	return f.endWrite()
}

// A ContinuationFrame is used to continue a sequence of header block fragments.
// See http://http2.github.io/http2-spec/#rfc.section.6.10
type xhttp2ContinuationFrame struct {
	xhttp2FrameHeader
	headerFragBuf []byte
}

func xhttp2parseContinuationFrame(fh xhttp2FrameHeader, p []byte) (xhttp2Frame, error) {
	if fh.StreamID == 0 {
		return nil, xhttp2connError{xhttp2ErrCodeProtocol, "CONTINUATION frame with stream ID 0"}
	}
	return &xhttp2ContinuationFrame{fh, p}, nil
}

func (f *xhttp2ContinuationFrame) HeaderBlockFragment() []byte {
	f.checkValid()
	return f.headerFragBuf
}

func (f *xhttp2ContinuationFrame) HeadersEnded() bool {
	return f.xhttp2FrameHeader.Flags.Has(xhttp2FlagContinuationEndHeaders)
}

// WriteContinuation writes a CONTINUATION frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *xhttp2Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error {
	if !xhttp2validStreamID(streamID) && !f.AllowIllegalWrites {
		return xhttp2errStreamID
	}
	var flags xhttp2Flags
	if endHeaders {
		flags |= xhttp2FlagContinuationEndHeaders
	}
	f.startWrite(xhttp2FrameContinuation, flags, streamID)
	f.wbuf = append(f.wbuf, headerBlockFragment...)
	return f.endWrite()
}

// A PushPromiseFrame is used to initiate a server stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.6
type xhttp2PushPromiseFrame struct {
	xhttp2FrameHeader
	PromiseID     uint32
	headerFragBuf []byte // not owned
}

func (f *xhttp2PushPromiseFrame) HeaderBlockFragment() []byte {
	f.checkValid()
	return f.headerFragBuf
}

func (f *xhttp2PushPromiseFrame) HeadersEnded() bool {
	return f.xhttp2FrameHeader.Flags.Has(xhttp2FlagPushPromiseEndHeaders)
}

func xhttp2parsePushPromise(fh xhttp2FrameHeader, p []byte) (_ xhttp2Frame, err error) {
	pp := &xhttp2PushPromiseFrame{
		xhttp2FrameHeader: fh,
	}
	if pp.StreamID == 0 {

		return nil, xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	// The PUSH_PROMISE frame includes optional padding.
	// Padding fields and flags are identical to those defined for DATA frames
	var padLength uint8
	if fh.Flags.Has(xhttp2FlagPushPromisePadded) {
		if p, padLength, err = xhttp2readByte(p); err != nil {
			return
		}
	}

	p, pp.PromiseID, err = xhttp2readUint32(p)
	if err != nil {
		return
	}
	pp.PromiseID = pp.PromiseID & (1<<31 - 1)

	if int(padLength) > len(p) {

		return nil, xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	pp.headerFragBuf = p[:len(p)-int(padLength)]
	return pp, nil
}

// PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.
type xhttp2PushPromiseParam struct {
	// StreamID is the required Stream ID to initiate.
	StreamID uint32

	// PromiseID is the required Stream ID which this
	// Push Promises
	PromiseID uint32

	// BlockFragment is part (or all) of a Header Block.
	BlockFragment []byte

	// EndHeaders indicates that this frame contains an entire
	// header block and is not followed by any
	// CONTINUATION frames.
	EndHeaders bool

	// PadLength is the optional number of bytes of zeros to add
	// to this frame.
	PadLength uint8
}

// WritePushPromise writes a single PushPromise Frame.
//
// As with Header Frames, This is the low level call for writing
// individual frames. Continuation frames are handled elsewhere.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
func (f *xhttp2Framer) WritePushPromise(p xhttp2PushPromiseParam) error {
	if !xhttp2validStreamID(p.StreamID) && !f.AllowIllegalWrites {
		return xhttp2errStreamID
	}
	var flags xhttp2Flags
	if p.PadLength != 0 {
		flags |= xhttp2FlagPushPromisePadded
	}
	if p.EndHeaders {
		flags |= xhttp2FlagPushPromiseEndHeaders
	}
	f.startWrite(xhttp2FramePushPromise, flags, p.StreamID)
	if p.PadLength != 0 {
		f.writeByte(p.PadLength)
	}
	if !xhttp2validStreamID(p.PromiseID) && !f.AllowIllegalWrites {
		return xhttp2errStreamID
	}
	f.writeUint32(p.PromiseID)
	f.wbuf = append(f.wbuf, p.BlockFragment...)
	f.wbuf = append(f.wbuf, xhttp2padZeros[:p.PadLength]...)
	return f.endWrite()
}

// WriteRawFrame writes a raw frame. This can be used to write
// extension frames unknown to this package.
func (f *xhttp2Framer) WriteRawFrame(t xhttp2FrameType, flags xhttp2Flags, streamID uint32, payload []byte) error {
	f.startWrite(t, flags, streamID)
	f.writeBytes(payload)
	return f.endWrite()
}

func xhttp2readByte(p []byte) (remain []byte, b byte, err error) {
	if len(p) == 0 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	return p[1:], p[0], nil
}

func xhttp2readUint32(p []byte) (remain []byte, v uint32, err error) {
	if len(p) < 4 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	return p[4:], binary.BigEndian.Uint32(p[:4]), nil
}

type xhttp2streamEnder interface {
	StreamEnded() bool
}

type xhttp2headersEnder interface {
	HeadersEnded() bool
}

type xhttp2headersOrContinuation interface {
	xhttp2headersEnder
	HeaderBlockFragment() []byte
}

// A MetaHeadersFrame is the representation of one HEADERS frame and
// zero or more contiguous CONTINUATION frames and the decoding of
// their HPACK-encoded contents.
//
// This type of frame does not appear on the wire and is only returned
// by the Framer when Framer.ReadMetaHeaders is set.
type xhttp2MetaHeadersFrame struct {
	*xhttp2HeadersFrame

	// Fields are the fields contained in the HEADERS and
	// CONTINUATION frames. The underlying slice is owned by the
	// Framer and must not be retained after the next call to
	// ReadFrame.
	//
	// Fields are guaranteed to be in the correct http2 order and
	// not have unknown pseudo header fields or invalid header
	// field names or values. Required pseudo header fields may be
	// missing, however. Use the MetaHeadersFrame.Pseudo accessor
	// method access pseudo headers.
	Fields []hpack.HeaderField

	// Truncated is whether the max header list size limit was hit
	// and Fields is incomplete. The hpack decoder state is still
	// valid, however.
	Truncated bool
}

// PseudoValue returns the given pseudo header field's value.
// The provided pseudo field should not contain the leading colon.
func (mh *xhttp2MetaHeadersFrame) PseudoValue(pseudo string) string {
	for _, hf := range mh.Fields {
		if !hf.IsPseudo() {
			return ""
		}
		if hf.Name[1:] == pseudo {
			return hf.Value
		}
	}
	return ""
}

// RegularFields returns the regular (non-pseudo) header fields of mh.
// The caller does not own the returned slice.
func (mh *xhttp2MetaHeadersFrame) RegularFields() []hpack.HeaderField {
	for i, hf := range mh.Fields {
		if !hf.IsPseudo() {
			return mh.Fields[i:]
		}
	}
	return nil
}

// PseudoFields returns the pseudo header fields of mh.
// The caller does not own the returned slice.
func (mh *xhttp2MetaHeadersFrame) PseudoFields() []hpack.HeaderField {
	for i, hf := range mh.Fields {
		if !hf.IsPseudo() {
			return mh.Fields[:i]
		}
	}
	return mh.Fields
}

func (mh *xhttp2MetaHeadersFrame) checkPseudos() error {
	var isRequest, isResponse bool
	pf := mh.PseudoFields()
	for i, hf := range pf {
		switch hf.Name {
		case ":method", ":path", ":scheme", ":authority":
			isRequest = true
		case ":status":
			isResponse = true
		default:
			return xhttp2pseudoHeaderError(hf.Name)
		}

		for _, hf2 := range pf[:i] {
			if hf.Name == hf2.Name {
				return xhttp2duplicatePseudoHeaderError(hf.Name)
			}
		}
	}
	if isRequest && isResponse {
		return xhttp2errMixPseudoHeaderTypes
	}
	return nil
}

func (fr *xhttp2Framer) maxHeaderStringLen() int {
	v := fr.maxHeaderListSize()
	if uint32(int(v)) == v {
		return int(v)
	}

	return 0
}

// readMetaFrame returns 0 or more CONTINUATION frames from fr and
// merge them into into the provided hf and returns a MetaHeadersFrame
// with the decoded hpack values.
func (fr *xhttp2Framer) readMetaFrame(hf *xhttp2HeadersFrame) (*xhttp2MetaHeadersFrame, error) {
	if fr.AllowIllegalReads {
		return nil, errors.New("illegal use of AllowIllegalReads with ReadMetaHeaders")
	}
	mh := &xhttp2MetaHeadersFrame{
		xhttp2HeadersFrame: hf,
	}
	var remainSize = fr.maxHeaderListSize()
	var sawRegular bool

	var invalid error // pseudo header field errors
	hdec := fr.ReadMetaHeaders
	hdec.SetEmitEnabled(true)
	hdec.SetMaxStringLength(fr.maxHeaderStringLen())
	hdec.SetEmitFunc(func(hf hpack.HeaderField) {
		if xhttp2VerboseLogs && fr.logReads {
			fr.debugReadLoggerf("http2: decoded hpack field %+v", hf)
		}
		if !httplex.ValidHeaderFieldValue(hf.Value) {
			invalid = xhttp2headerFieldValueError(hf.Value)
		}
		isPseudo := strings.HasPrefix(hf.Name, ":")
		if isPseudo {
			if sawRegular {
				invalid = xhttp2errPseudoAfterRegular
			}
		} else {
			sawRegular = true
			if !xhttp2validWireHeaderFieldName(hf.Name) {
				invalid = xhttp2headerFieldNameError(hf.Name)
			}
		}

		if invalid != nil {
			hdec.SetEmitEnabled(false)
			return
		}

		size := hf.Size()
		if size > remainSize {
			hdec.SetEmitEnabled(false)
			mh.Truncated = true
			return
		}
		remainSize -= size

		mh.Fields = append(mh.Fields, hf)
	})

	defer hdec.SetEmitFunc(func(hf hpack.HeaderField) {})

	var hc xhttp2headersOrContinuation = hf
	for {
		frag := hc.HeaderBlockFragment()
		if _, err := hdec.Write(frag); err != nil {
			return nil, xhttp2ConnectionError(xhttp2ErrCodeCompression)
		}

		if hc.HeadersEnded() {
			break
		}
		if f, err := fr.ReadFrame(); err != nil {
			return nil, err
		} else {
			hc = f.(*xhttp2ContinuationFrame)
		}
	}

	mh.xhttp2HeadersFrame.headerFragBuf = nil
	mh.xhttp2HeadersFrame.invalidate()

	if err := hdec.Close(); err != nil {
		return nil, xhttp2ConnectionError(xhttp2ErrCodeCompression)
	}
	if invalid != nil {
		fr.errDetail = invalid
		if xhttp2VerboseLogs {
			log.Printf("http2: invalid header: %v", invalid)
		}
		return nil, xhttp2StreamError{mh.StreamID, xhttp2ErrCodeProtocol, invalid}
	}
	if err := mh.checkPseudos(); err != nil {
		fr.errDetail = err
		if xhttp2VerboseLogs {
			log.Printf("http2: invalid pseudo headers: %v", err)
		}
		return nil, xhttp2StreamError{mh.StreamID, xhttp2ErrCodeProtocol, err}
	}
	return mh, nil
}

func xhttp2summarizeFrame(f xhttp2Frame) string {
	var buf bytes.Buffer
	f.Header().writeDebug(&buf)
	switch f := f.(type) {
	case *xhttp2SettingsFrame:
		n := 0
		f.ForeachSetting(func(s xhttp2Setting) error {
			n++
			if n == 1 {
				buf.WriteString(", settings:")
			}
			fmt.Fprintf(&buf, " %v=%v,", s.ID, s.Val)
			return nil
		})
		if n > 0 {
			buf.Truncate(buf.Len() - 1)
		}
	case *xhttp2DataFrame:
		data := f.Data()
		const max = 256
		if len(data) > max {
			data = data[:max]
		}
		fmt.Fprintf(&buf, " data=%q", data)
		if len(f.Data()) > max {
			fmt.Fprintf(&buf, " (%d bytes omitted)", len(f.Data())-max)
		}
	case *xhttp2WindowUpdateFrame:
		if f.StreamID == 0 {
			buf.WriteString(" (conn)")
		}
		fmt.Fprintf(&buf, " incr=%v", f.Increment)
	case *xhttp2PingFrame:
		fmt.Fprintf(&buf, " ping=%q", f.Data[:])
	case *xhttp2GoAwayFrame:
		fmt.Fprintf(&buf, " LastStreamID=%v ErrCode=%v Debug=%q",
			f.LastStreamID, f.ErrCode, f.debugData)
	case *xhttp2RSTStreamFrame:
		fmt.Fprintf(&buf, " ErrCode=%v", f.ErrCode)
	}
	return buf.String()
}

func xhttp2transportExpectContinueTimeout(t1 *http.Transport) time.Duration {
	return t1.ExpectContinueTimeout
}

// isBadCipher reports whether the cipher is blacklisted by the HTTP/2 spec.
func xhttp2isBadCipher(cipher uint16) bool {
	switch cipher {
	case tls.TLS_RSA_WITH_RC4_128_SHA,
		tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
		tls.TLS_RSA_WITH_AES_128_CBC_SHA,
		tls.TLS_RSA_WITH_AES_256_CBC_SHA,
		tls.TLS_RSA_WITH_AES_128_GCM_SHA256,
		tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
		tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
		tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
		tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
		tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
		tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
		tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
		tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:

		return true
	default:
		return false
	}
}

type xhttp2contextContext interface {
	context.Context
}

func xhttp2serverConnBaseContext(c net.Conn, opts *xhttp2ServeConnOpts) (ctx xhttp2contextContext, cancel func()) {
	ctx, cancel = context.WithCancel(context.Background())
	ctx = context.WithValue(ctx, http.LocalAddrContextKey, c.LocalAddr())
	if hs := opts.baseConfig(); hs != nil {
		ctx = context.WithValue(ctx, http.ServerContextKey, hs)
	}
	return
}

func xhttp2contextWithCancel(ctx xhttp2contextContext) (_ xhttp2contextContext, cancel func()) {
	return context.WithCancel(ctx)
}

func xhttp2requestWithContext(req *http.Request, ctx xhttp2contextContext) *http.Request {
	return req.WithContext(ctx)
}

type xhttp2clientTrace httptrace.ClientTrace

func xhttp2reqContext(r *http.Request) context.Context { return r.Context() }

func (t *xhttp2Transport) idleConnTimeout() time.Duration {
	if t.t1 != nil {
		return t.t1.IdleConnTimeout
	}
	return 0
}

func xhttp2setResponseUncompressed(res *http.Response) { res.Uncompressed = true }

func xhttp2traceGotConn(req *http.Request, cc *xhttp2ClientConn) {
	trace := httptrace.ContextClientTrace(req.Context())
	if trace == nil || trace.GotConn == nil {
		return
	}
	ci := httptrace.GotConnInfo{Conn: cc.tconn}
	cc.mu.Lock()
	ci.Reused = cc.nextStreamID > 1
	ci.WasIdle = len(cc.streams) == 0 && ci.Reused
	if ci.WasIdle && !cc.lastActive.IsZero() {
		ci.IdleTime = time.Now().Sub(cc.lastActive)
	}
	cc.mu.Unlock()

	trace.GotConn(ci)
}

func xhttp2traceWroteHeaders(trace *xhttp2clientTrace) {
	if trace != nil && trace.WroteHeaders != nil {
		trace.WroteHeaders()
	}
}

func xhttp2traceGot100Continue(trace *xhttp2clientTrace) {
	if trace != nil && trace.Got100Continue != nil {
		trace.Got100Continue()
	}
}

func xhttp2traceWait100Continue(trace *xhttp2clientTrace) {
	if trace != nil && trace.Wait100Continue != nil {
		trace.Wait100Continue()
	}
}

func xhttp2traceWroteRequest(trace *xhttp2clientTrace, err error) {
	if trace != nil && trace.WroteRequest != nil {
		trace.WroteRequest(httptrace.WroteRequestInfo{Err: err})
	}
}

func xhttp2traceFirstResponseByte(trace *xhttp2clientTrace) {
	if trace != nil && trace.GotFirstResponseByte != nil {
		trace.GotFirstResponseByte()
	}
}

func xhttp2requestTrace(req *http.Request) *xhttp2clientTrace {
	trace := httptrace.ContextClientTrace(req.Context())
	return (*xhttp2clientTrace)(trace)
}

// Ping sends a PING frame to the server and waits for the ack.
func (cc *xhttp2ClientConn) Ping(ctx context.Context) error {
	return cc.ping(ctx)
}

// temporary copy of Go 1.7's private tls.Config.clone:
func xhttp2cloneTLSConfig(c *tls.Config) *tls.Config {
	return &tls.Config{
		Rand:                        c.Rand,
		Time:                        c.Time,
		Certificates:                c.Certificates,
		NameToCertificate:           c.NameToCertificate,
		GetCertificate:              c.GetCertificate,
		RootCAs:                     c.RootCAs,
		NextProtos:                  c.NextProtos,
		ServerName:                  c.ServerName,
		ClientAuth:                  c.ClientAuth,
		ClientCAs:                   c.ClientCAs,
		InsecureSkipVerify:          c.InsecureSkipVerify,
		CipherSuites:                c.CipherSuites,
		PreferServerCipherSuites:    c.PreferServerCipherSuites,
		SessionTicketsDisabled:      c.SessionTicketsDisabled,
		SessionTicketKey:            c.SessionTicketKey,
		ClientSessionCache:          c.ClientSessionCache,
		MinVersion:                  c.MinVersion,
		MaxVersion:                  c.MaxVersion,
		CurvePreferences:            c.CurvePreferences,
		DynamicRecordSizingDisabled: c.DynamicRecordSizingDisabled,
		Renegotiation:               c.Renegotiation,
	}
}

var xhttp2DebugGoroutines = os.Getenv("DEBUG_HTTP2_GOROUTINES") == "1"

type xhttp2goroutineLock uint64

func xhttp2newGoroutineLock() xhttp2goroutineLock {
	if !xhttp2DebugGoroutines {
		return 0
	}
	return xhttp2goroutineLock(xhttp2curGoroutineID())
}

func (g xhttp2goroutineLock) check() {
	if !xhttp2DebugGoroutines {
		return
	}
	if xhttp2curGoroutineID() != uint64(g) {
		panic("running on the wrong goroutine")
	}
}

func (g xhttp2goroutineLock) checkNotOn() {
	if !xhttp2DebugGoroutines {
		return
	}
	if xhttp2curGoroutineID() == uint64(g) {
		panic("running on the wrong goroutine")
	}
}

var xhttp2goroutineSpace = []byte("goroutine ")

func xhttp2curGoroutineID() uint64 {
	bp := xhttp2littleBuf.Get().(*[]byte)
	defer xhttp2littleBuf.Put(bp)
	b := *bp
	b = b[:runtime.Stack(b, false)]

	b = bytes.TrimPrefix(b, xhttp2goroutineSpace)
	i := bytes.IndexByte(b, ' ')
	if i < 0 {
		panic(fmt.Sprintf("No space found in %q", b))
	}
	b = b[:i]
	n, err := xhttp2parseUintBytes(b, 10, 64)
	if err != nil {
		panic(fmt.Sprintf("Failed to parse goroutine ID out of %q: %v", b, err))
	}
	return n
}

var xhttp2littleBuf = sync.Pool{
	New: func() interface{} {
		buf := make([]byte, 64)
		return &buf
	},
}

// parseUintBytes is like strconv.ParseUint, but using a []byte.
func xhttp2parseUintBytes(s []byte, base int, bitSize int) (n uint64, err error) {
	var cutoff, maxVal uint64

	if bitSize == 0 {
		bitSize = int(strconv.IntSize)
	}

	s0 := s
	switch {
	case len(s) < 1:
		err = strconv.ErrSyntax
		goto Error

	case 2 <= base && base <= 36:

	case base == 0:

		switch {
		case s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):
			base = 16
			s = s[2:]
			if len(s) < 1 {
				err = strconv.ErrSyntax
				goto Error
			}
		case s[0] == '0':
			base = 8
		default:
			base = 10
		}

	default:
		err = errors.New("invalid base " + strconv.Itoa(base))
		goto Error
	}

	n = 0
	cutoff = xhttp2cutoff64(base)
	maxVal = 1<<uint(bitSize) - 1

	for i := 0; i < len(s); i++ {
		var v byte
		d := s[i]
		switch {
		case '0' <= d && d <= '9':
			v = d - '0'
		case 'a' <= d && d <= 'z':
			v = d - 'a' + 10
		case 'A' <= d && d <= 'Z':
			v = d - 'A' + 10
		default:
			n = 0
			err = strconv.ErrSyntax
			goto Error
		}
		if int(v) >= base {
			n = 0
			err = strconv.ErrSyntax
			goto Error
		}

		if n >= cutoff {

			n = 1<<64 - 1
			err = strconv.ErrRange
			goto Error
		}
		n *= uint64(base)

		n1 := n + uint64(v)
		if n1 < n || n1 > maxVal {

			n = 1<<64 - 1
			err = strconv.ErrRange
			goto Error
		}
		n = n1
	}

	return n, nil

Error:
	return n, &strconv.NumError{Func: "ParseUint", Num: string(s0), Err: err}
}

// Return the first number n such that n*base >= 1<<64.
func xhttp2cutoff64(base int) uint64 {
	if base < 2 {
		return 0
	}
	return (1<<64-1)/uint64(base) + 1
}

var (
	xhttp2commonLowerHeader = map[string]string{} // Go-Canonical-Case -> lower-case
	xhttp2commonCanonHeader = map[string]string{} // lower-case -> Go-Canonical-Case
)

func init() {
	for _, v := range []string{
		"accept",
		"accept-charset",
		"accept-encoding",
		"accept-language",
		"accept-ranges",
		"age",
		"access-control-allow-origin",
		"allow",
		"authorization",
		"cache-control",
		"content-disposition",
		"content-encoding",
		"content-language",
		"content-length",
		"content-location",
		"content-range",
		"content-type",
		"cookie",
		"date",
		"etag",
		"expect",
		"expires",
		"from",
		"host",
		"if-match",
		"if-modified-since",
		"if-none-match",
		"if-unmodified-since",
		"last-modified",
		"link",
		"location",
		"max-forwards",
		"proxy-authenticate",
		"proxy-authorization",
		"range",
		"referer",
		"refresh",
		"retry-after",
		"server",
		"set-cookie",
		"strict-transport-security",
		"trailer",
		"transfer-encoding",
		"user-agent",
		"vary",
		"via",
		"www-authenticate",
	} {
		chk := http.CanonicalHeaderKey(v)
		xhttp2commonLowerHeader[chk] = v
		xhttp2commonCanonHeader[v] = chk
	}
}

func xhttp2lowerHeader(v string) string {
	if s, ok := xhttp2commonLowerHeader[v]; ok {
		return s
	}
	return strings.ToLower(v)
}

var (
	xhttp2VerboseLogs    bool
	xhttp2logFrameWrites bool
	xhttp2logFrameReads  bool
	xhttp2inTests        bool
)

func init() {
	e := os.Getenv("GODEBUG")
	if strings.Contains(e, "http2debug=1") {
		xhttp2VerboseLogs = true
	}
	if strings.Contains(e, "http2debug=2") {
		xhttp2VerboseLogs = true
		xhttp2logFrameWrites = true
		xhttp2logFrameReads = true
	}
}

const (
	// ClientPreface is the string that must be sent by new
	// connections from clients.
	xhttp2ClientPreface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"

	// SETTINGS_MAX_FRAME_SIZE default
	// http://http2.github.io/http2-spec/#rfc.section.6.5.2
	xhttp2initialMaxFrameSize = 16384

	// NextProtoTLS is the NPN/ALPN protocol negotiated during
	// HTTP/2's TLS setup.
	xhttp2NextProtoTLS = "h2"

	// http://http2.github.io/http2-spec/#SettingValues
	xhttp2initialHeaderTableSize = 4096

	xhttp2initialWindowSize = 65535 // 6.9.2 Initial Flow Control Window Size

	xhttp2defaultMaxReadFrameSize = 1 << 20
)

var (
	xhttp2clientPreface = []byte(xhttp2ClientPreface)
)

type xhttp2streamState int

// HTTP/2 stream states.
//
// See http://tools.ietf.org/html/rfc7540#section-5.1.
//
// For simplicity, the server code merges "reserved (local)" into
// "half-closed (remote)". This is one less state transition to track.
// The only downside is that we send PUSH_PROMISEs slightly less
// liberally than allowable. More discussion here:
// https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html
//
// "reserved (remote)" is omitted since the client code does not
// support server push.
const (
	xhttp2stateIdle xhttp2streamState = iota
	xhttp2stateOpen
	xhttp2stateHalfClosedLocal
	xhttp2stateHalfClosedRemote
	xhttp2stateClosed
)

var xhttp2stateName = [...]string{
	xhttp2stateIdle:             "Idle",
	xhttp2stateOpen:             "Open",
	xhttp2stateHalfClosedLocal:  "HalfClosedLocal",
	xhttp2stateHalfClosedRemote: "HalfClosedRemote",
	xhttp2stateClosed:           "Closed",
}

func (st xhttp2streamState) String() string {
	return xhttp2stateName[st]
}

// Setting is a setting parameter: which setting it is, and its value.
type xhttp2Setting struct {
	// ID is which setting is being set.
	// See http://http2.github.io/http2-spec/#SettingValues
	ID xhttp2SettingID

	// Val is the value.
	Val uint32
}

func (s xhttp2Setting) String() string {
	return fmt.Sprintf("[%v = %d]", s.ID, s.Val)
}

// Valid reports whether the setting is valid.
func (s xhttp2Setting) Valid() error {

	switch s.ID {
	case xhttp2SettingEnablePush:
		if s.Val != 1 && s.Val != 0 {
			return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
		}
	case xhttp2SettingInitialWindowSize:
		if s.Val > 1<<31-1 {
			return xhttp2ConnectionError(xhttp2ErrCodeFlowControl)
		}
	case xhttp2SettingMaxFrameSize:
		if s.Val < 16384 || s.Val > 1<<24-1 {
			return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
		}
	}
	return nil
}

// A SettingID is an HTTP/2 setting as defined in
// http://http2.github.io/http2-spec/#iana-settings
type xhttp2SettingID uint16

const (
	xhttp2SettingHeaderTableSize      xhttp2SettingID = 0x1
	xhttp2SettingEnablePush           xhttp2SettingID = 0x2
	xhttp2SettingMaxConcurrentStreams xhttp2SettingID = 0x3
	xhttp2SettingInitialWindowSize    xhttp2SettingID = 0x4
	xhttp2SettingMaxFrameSize         xhttp2SettingID = 0x5
	xhttp2SettingMaxHeaderListSize    xhttp2SettingID = 0x6
)

var xhttp2settingName = map[xhttp2SettingID]string{
	xhttp2SettingHeaderTableSize:      "HEADER_TABLE_SIZE",
	xhttp2SettingEnablePush:           "ENABLE_PUSH",
	xhttp2SettingMaxConcurrentStreams: "MAX_CONCURRENT_STREAMS",
	xhttp2SettingInitialWindowSize:    "INITIAL_WINDOW_SIZE",
	xhttp2SettingMaxFrameSize:         "MAX_FRAME_SIZE",
	xhttp2SettingMaxHeaderListSize:    "MAX_HEADER_LIST_SIZE",
}

func (s xhttp2SettingID) String() string {
	if v, ok := xhttp2settingName[s]; ok {
		return v
	}
	return fmt.Sprintf("UNKNOWN_SETTING_%d", uint16(s))
}

var (
	xhttp2errInvalidHeaderFieldName  = errors.New("http2: invalid header field name")
	xhttp2errInvalidHeaderFieldValue = errors.New("http2: invalid header field value")
)

// validWireHeaderFieldName reports whether v is a valid header field
// name (key). See httplex.ValidHeaderName for the base rules.
//
// Further, http2 says:
//   "Just as in HTTP/1.x, header field names are strings of ASCII
//   characters that are compared in a case-insensitive
//   fashion. However, header field names MUST be converted to
//   lowercase prior to their encoding in HTTP/2. "
func xhttp2validWireHeaderFieldName(v string) bool {
	if len(v) == 0 {
		return false
	}
	for _, r := range v {
		if !httplex.IsTokenRune(r) {
			return false
		}
		if 'A' <= r && r <= 'Z' {
			return false
		}
	}
	return true
}

var xhttp2httpCodeStringCommon = map[int]string{} // n -> strconv.Itoa(n)

func init() {
	for i := 100; i <= 999; i++ {
		if v := http.StatusText(i); v != "" {
			xhttp2httpCodeStringCommon[i] = strconv.Itoa(i)
		}
	}
}

func xhttp2httpCodeString(code int) string {
	if s, ok := xhttp2httpCodeStringCommon[code]; ok {
		return s
	}
	return strconv.Itoa(code)
}

// from pkg io
type xhttp2stringWriter interface {
	WriteString(s string) (n int, err error)
}

// A gate lets two goroutines coordinate their activities.
type xhttp2gate chan struct{}

func (g xhttp2gate) Done() { g <- struct{}{} }

func (g xhttp2gate) Wait() { <-g }

// A closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed).
type xhttp2closeWaiter chan struct{}

// Init makes a closeWaiter usable.
// It exists because so a closeWaiter value can be placed inside a
// larger struct and have the Mutex and Cond's memory in the same
// allocation.
func (cw *xhttp2closeWaiter) Init() {
	*cw = make(chan struct{})
}

// Close marks the closeWaiter as closed and unblocks any waiters.
func (cw xhttp2closeWaiter) Close() {
	close(cw)
}

// Wait waits for the closeWaiter to become closed.
func (cw xhttp2closeWaiter) Wait() {
	<-cw
}

// bufferedWriter is a buffered writer that writes to w.
// Its buffered writer is lazily allocated as needed, to minimize
// idle memory usage with many connections.
type xhttp2bufferedWriter struct {
	w  io.Writer     // immutable
	bw *bufio.Writer // non-nil when data is buffered
}

func xhttp2newBufferedWriter(w io.Writer) *xhttp2bufferedWriter {
	return &xhttp2bufferedWriter{w: w}
}

// bufWriterPoolBufferSize is the size of bufio.Writer's
// buffers created using bufWriterPool.
//
// TODO: pick a less arbitrary value? this is a bit under
// (3 x typical 1500 byte MTU) at least. Other than that,
// not much thought went into it.
const xhttp2bufWriterPoolBufferSize = 4 << 10

var xhttp2bufWriterPool = sync.Pool{
	New: func() interface{} {
		return bufio.NewWriterSize(nil, xhttp2bufWriterPoolBufferSize)
	},
}

func (w *xhttp2bufferedWriter) Available() int {
	if w.bw == nil {
		return xhttp2bufWriterPoolBufferSize
	}
	return w.bw.Available()
}

func (w *xhttp2bufferedWriter) Write(p []byte) (n int, err error) {
	if w.bw == nil {
		bw := xhttp2bufWriterPool.Get().(*bufio.Writer)
		bw.Reset(w.w)
		w.bw = bw
	}
	return w.bw.Write(p)
}

func (w *xhttp2bufferedWriter) Flush() error {
	bw := w.bw
	if bw == nil {
		return nil
	}
	err := bw.Flush()
	bw.Reset(nil)
	xhttp2bufWriterPool.Put(bw)
	w.bw = nil
	return err
}

func xhttp2mustUint31(v int32) uint32 {
	if v < 0 || v > 2147483647 {
		panic("out of range")
	}
	return uint32(v)
}

// bodyAllowedForStatus reports whether a given response status code
// permits a body. See RFC 2616, section 4.4.
func xhttp2bodyAllowedForStatus(status int) bool {
	switch {
	case status >= 100 && status <= 199:
		return false
	case status == 204:
		return false
	case status == 304:
		return false
	}
	return true
}

type xhttp2httpError struct {
	msg     string
	timeout bool
}

func (e *xhttp2httpError) Error() string { return e.msg }

func (e *xhttp2httpError) Timeout() bool { return e.timeout }

func (e *xhttp2httpError) Temporary() bool { return true }

var xhttp2errTimeout error = &xhttp2httpError{msg: "http2: timeout awaiting response headers", timeout: true}

type xhttp2connectionStater interface {
	ConnectionState() tls.ConnectionState
}

var xhttp2sorterPool = sync.Pool{New: func() interface{} { return new(xhttp2sorter) }}

type xhttp2sorter struct {
	v []string // owned by sorter
}

func (s *xhttp2sorter) Len() int { return len(s.v) }

func (s *xhttp2sorter) Swap(i, j int) { s.v[i], s.v[j] = s.v[j], s.v[i] }

func (s *xhttp2sorter) Less(i, j int) bool { return s.v[i] < s.v[j] }

// Keys returns the sorted keys of h.
//
// The returned slice is only valid until s used again or returned to
// its pool.
func (s *xhttp2sorter) Keys(h http.Header) []string {
	keys := s.v[:0]
	for k := range h {
		keys = append(keys, k)
	}
	s.v = keys
	sort.Sort(s)
	return keys
}

func (s *xhttp2sorter) SortStrings(ss []string) {

	save := s.v
	s.v = ss
	sort.Sort(s)
	s.v = save
}

// validPseudoPath reports whether v is a valid :path pseudo-header
// value. It must be either:
//
//     *) a non-empty string starting with '/', but not with with "//",
//     *) the string '*', for OPTIONS requests.
//
// For now this is only used a quick check for deciding when to clean
// up Opaque URLs before sending requests from the Transport.
// See golang.org/issue/16847
func xhttp2validPseudoPath(v string) bool {
	return (len(v) > 0 && v[0] == '/' && (len(v) == 1 || v[1] != '/')) || v == "*"
}

func xhttp2configureServer18(h1 *http.Server, h2 *xhttp2Server) error {

	return nil
}

func xhttp2shouldLogPanic(panicValue interface{}) bool {
	return panicValue != nil
}

func xhttp2reqGetBody(req *http.Request) func() (io.ReadCloser, error) {
	return nil
}

func xhttp2reqBodyIsNoBody(io.ReadCloser) bool { return false }

// pipe is a goroutine-safe io.Reader/io.Writer pair.  It's like
// io.Pipe except there are no PipeReader/PipeWriter halves, and the
// underlying buffer is an interface. (io.Pipe is always unbuffered)
type xhttp2pipe struct {
	mu       sync.Mutex
	c        sync.Cond // c.L lazily initialized to &p.mu
	b        xhttp2pipeBuffer
	err      error         // read error once empty. non-nil means closed.
	breakErr error         // immediate read error (caller doesn't see rest of b)
	donec    chan struct{} // closed on error
	readFn   func()        // optional code to run in Read before error
}

type xhttp2pipeBuffer interface {
	Len() int
	io.Writer
	io.Reader
}

func (p *xhttp2pipe) Len() int {
	p.mu.Lock()
	defer p.mu.Unlock()
	return p.b.Len()
}

// Read waits until data is available and copies bytes
// from the buffer into p.
func (p *xhttp2pipe) Read(d []byte) (n int, err error) {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.c.L == nil {
		p.c.L = &p.mu
	}
	for {
		if p.breakErr != nil {
			return 0, p.breakErr
		}
		if p.b.Len() > 0 {
			return p.b.Read(d)
		}
		if p.err != nil {
			if p.readFn != nil {
				p.readFn()
				p.readFn = nil
			}
			return 0, p.err
		}
		p.c.Wait()
	}
}

var xhttp2errClosedPipeWrite = errors.New("write on closed buffer")

// Write copies bytes from p into the buffer and wakes a reader.
// It is an error to write more data than the buffer can hold.
func (p *xhttp2pipe) Write(d []byte) (n int, err error) {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.c.L == nil {
		p.c.L = &p.mu
	}
	defer p.c.Signal()
	if p.err != nil {
		return 0, xhttp2errClosedPipeWrite
	}
	return p.b.Write(d)
}

// CloseWithError causes the next Read (waking up a current blocked
// Read if needed) to return the provided err after all data has been
// read.
//
// The error must be non-nil.
func (p *xhttp2pipe) CloseWithError(err error) { p.closeWithError(&p.err, err, nil) }

// BreakWithError causes the next Read (waking up a current blocked
// Read if needed) to return the provided err immediately, without
// waiting for unread data.
func (p *xhttp2pipe) BreakWithError(err error) { p.closeWithError(&p.breakErr, err, nil) }

// closeWithErrorAndCode is like CloseWithError but also sets some code to run
// in the caller's goroutine before returning the error.
func (p *xhttp2pipe) closeWithErrorAndCode(err error, fn func()) { p.closeWithError(&p.err, err, fn) }

func (p *xhttp2pipe) closeWithError(dst *error, err error, fn func()) {
	if err == nil {
		panic("err must be non-nil")
	}
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.c.L == nil {
		p.c.L = &p.mu
	}
	defer p.c.Signal()
	if *dst != nil {

		return
	}
	p.readFn = fn
	*dst = err
	p.closeDoneLocked()
}

// requires p.mu be held.
func (p *xhttp2pipe) closeDoneLocked() {
	if p.donec == nil {
		return
	}

	select {
	case <-p.donec:
	default:
		close(p.donec)
	}
}

// Err returns the error (if any) first set by BreakWithError or CloseWithError.
func (p *xhttp2pipe) Err() error {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.breakErr != nil {
		return p.breakErr
	}
	return p.err
}

// Done returns a channel which is closed if and when this pipe is closed
// with CloseWithError.
func (p *xhttp2pipe) Done() <-chan struct{} {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.donec == nil {
		p.donec = make(chan struct{})
		if p.err != nil || p.breakErr != nil {

			p.closeDoneLocked()
		}
	}
	return p.donec
}

const (
	xhttp2prefaceTimeout        = 10 * time.Second
	xhttp2firstSettingsTimeout  = 2 * time.Second // should be in-flight with preface anyway
	xhttp2handlerChunkWriteSize = 4 << 10
	xhttp2defaultMaxStreams     = 250 // TODO: make this 100 as the GFE seems to?
)

var (
	xhttp2errClientDisconnected = errors.New("client disconnected")
	xhttp2errClosedBody         = errors.New("body closed by handler")
	xhttp2errHandlerComplete    = errors.New("http2: request body closed due to handler exiting")
	xhttp2errStreamClosed       = errors.New("http2: stream closed")
)

var xhttp2responseWriterStatePool = sync.Pool{
	New: func() interface{} {
		rws := &xhttp2responseWriterState{}
		rws.bw = bufio.NewWriterSize(xhttp2chunkWriter{rws}, xhttp2handlerChunkWriteSize)
		return rws
	},
}

// Test hooks.
var (
	xhttp2testHookOnConn        func()
	xhttp2testHookGetServerConn func(*xhttp2serverConn)
	xhttp2testHookOnPanicMu     *sync.Mutex // nil except in tests
	xhttp2testHookOnPanic       func(sc *xhttp2serverConn, panicVal interface{}) (rePanic bool)
)

// Server is an HTTP/2 server.
type xhttp2Server struct {
	// MaxHandlers limits the number of http.Handler ServeHTTP goroutines
	// which may run at a time over all connections.
	// Negative or zero no limit.
	// TODO: implement
	MaxHandlers int

	// MaxConcurrentStreams optionally specifies the number of
	// concurrent streams that each client may have open at a
	// time. This is unrelated to the number of http.Handler goroutines
	// which may be active globally, which is MaxHandlers.
	// If zero, MaxConcurrentStreams defaults to at least 100, per
	// the HTTP/2 spec's recommendations.
	MaxConcurrentStreams uint32

	// MaxReadFrameSize optionally specifies the largest frame
	// this server is willing to read. A valid value is between
	// 16k and 16M, inclusive. If zero or otherwise invalid, a
	// default value is used.
	MaxReadFrameSize uint32

	// PermitProhibitedCipherSuites, if true, permits the use of
	// cipher suites prohibited by the HTTP/2 spec.
	PermitProhibitedCipherSuites bool

	// IdleTimeout specifies how long until idle clients should be
	// closed with a GOAWAY frame. PING frames are not considered
	// activity for the purposes of IdleTimeout.
	IdleTimeout time.Duration

	// NewWriteScheduler constructs a write scheduler for a connection.
	// If nil, a default scheduler is chosen.
	NewWriteScheduler func() xhttp2WriteScheduler
}

func (s *xhttp2Server) maxReadFrameSize() uint32 {
	if v := s.MaxReadFrameSize; v >= xhttp2minMaxFrameSize && v <= xhttp2maxFrameSize {
		return v
	}
	return xhttp2defaultMaxReadFrameSize
}

func (s *xhttp2Server) maxConcurrentStreams() uint32 {
	if v := s.MaxConcurrentStreams; v > 0 {
		return v
	}
	return xhttp2defaultMaxStreams
}

// ConfigureServer adds HTTP/2 support to a net/http Server.
//
// The configuration conf may be nil.
//
// ConfigureServer must be called before s begins serving.
func xhttp2ConfigureServer(s *http.Server, conf *xhttp2Server) error {
	if s == nil {
		panic("nil *http.Server")
	}
	if conf == nil {
		conf = new(xhttp2Server)
	}
	if err := xhttp2configureServer18(s, conf); err != nil {
		return err
	}

	if s.TLSConfig == nil {
		s.TLSConfig = new(tls.Config)
	} else if s.TLSConfig.CipherSuites != nil {
		// If they already provided a CipherSuite list, return
		// an error if it has a bad order or is missing
		// ECDHE_RSA_WITH_AES_128_GCM_SHA256.
		const requiredCipher = tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
		haveRequired := false
		sawBad := false
		for i, cs := range s.TLSConfig.CipherSuites {
			if cs == requiredCipher {
				haveRequired = true
			}
			if xhttp2isBadCipher(cs) {
				sawBad = true
			} else if sawBad {
				return fmt.Errorf("http2: TLSConfig.CipherSuites index %d contains an HTTP/2-approved cipher suite (%#04x), but it comes after unapproved cipher suites. With this configuration, clients that don't support previous, approved cipher suites may be given an unapproved one and reject the connection.", i, cs)
			}
		}
		if !haveRequired {
			return fmt.Errorf("http2: TLSConfig.CipherSuites is missing HTTP/2-required TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")
		}
	}

	s.TLSConfig.PreferServerCipherSuites = true

	haveNPN := false
	for _, p := range s.TLSConfig.NextProtos {
		if p == xhttp2NextProtoTLS {
			haveNPN = true
			break
		}
	}
	if !haveNPN {
		s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, xhttp2NextProtoTLS)
	}

	if s.TLSNextProto == nil {
		s.TLSNextProto = map[string]func(*http.Server, *tls.Conn, http.Handler){}
	}
	protoHandler := func(hs *http.Server, c *tls.Conn, h http.Handler) {
		if xhttp2testHookOnConn != nil {
			xhttp2testHookOnConn()
		}
		conf.ServeConn(c, &xhttp2ServeConnOpts{
			Handler:    h,
			BaseConfig: hs,
		})
	}
	s.TLSNextProto[xhttp2NextProtoTLS] = protoHandler
	return nil
}

// ServeConnOpts are options for the Server.ServeConn method.
type xhttp2ServeConnOpts struct {
	// BaseConfig optionally sets the base configuration
	// for values. If nil, defaults are used.
	BaseConfig *http.Server

	// Handler specifies which handler to use for processing
	// requests. If nil, BaseConfig.Handler is used. If BaseConfig
	// or BaseConfig.Handler is nil, http.DefaultServeMux is used.
	Handler http.Handler
}

func (o *xhttp2ServeConnOpts) baseConfig() *http.Server {
	if o != nil && o.BaseConfig != nil {
		return o.BaseConfig
	}
	return new(http.Server)
}

func (o *xhttp2ServeConnOpts) handler() http.Handler {
	if o != nil {
		if o.Handler != nil {
			return o.Handler
		}
		if o.BaseConfig != nil && o.BaseConfig.Handler != nil {
			return o.BaseConfig.Handler
		}
	}
	return http.DefaultServeMux
}

// ServeConn serves HTTP/2 requests on the provided connection and
// blocks until the connection is no longer readable.
//
// ServeConn starts speaking HTTP/2 assuming that c has not had any
// reads or writes. It writes its initial settings frame and expects
// to be able to read the preface and settings frame from the
// client. If c has a ConnectionState method like a *tls.Conn, the
// ConnectionState is used to verify the TLS ciphersuite and to set
// the Request.TLS field in Handlers.
//
// ServeConn does not support h2c by itself. Any h2c support must be
// implemented in terms of providing a suitably-behaving net.Conn.
//
// The opts parameter is optional. If nil, default values are used.
func (s *xhttp2Server) ServeConn(c net.Conn, opts *xhttp2ServeConnOpts) {
	baseCtx, cancel := xhttp2serverConnBaseContext(c, opts)
	defer cancel()

	sc := &xhttp2serverConn{
		srv:               s,
		hs:                opts.baseConfig(),
		conn:              c,
		baseCtx:           baseCtx,
		remoteAddrStr:     c.RemoteAddr().String(),
		bw:                xhttp2newBufferedWriter(c),
		handler:           opts.handler(),
		streams:           make(map[uint32]*xhttp2stream),
		readFrameCh:       make(chan xhttp2readFrameResult),
		wantWriteFrameCh:  make(chan xhttp2FrameWriteRequest, 8),
		wantStartPushCh:   make(chan xhttp2startPushRequest, 8),
		wroteFrameCh:      make(chan xhttp2frameWriteResult, 1),
		bodyReadCh:        make(chan xhttp2bodyReadMsg),
		doneServing:       make(chan struct{}),
		clientMaxStreams:  math.MaxUint32,
		advMaxStreams:     s.maxConcurrentStreams(),
		initialWindowSize: xhttp2initialWindowSize,
		maxFrameSize:      xhttp2initialMaxFrameSize,
		headerTableSize:   xhttp2initialHeaderTableSize,
		serveG:            xhttp2newGoroutineLock(),
		pushEnabled:       true,
	}

	if s.NewWriteScheduler != nil {
		sc.writeSched = s.NewWriteScheduler()
	} else {
		sc.writeSched = xhttp2NewRandomWriteScheduler()
	}

	sc.flow.add(xhttp2initialWindowSize)
	sc.inflow.add(xhttp2initialWindowSize)
	sc.hpackEncoder = hpack.NewEncoder(&sc.headerWriteBuf)

	fr := xhttp2NewFramer(sc.bw, c)
	fr.ReadMetaHeaders = hpack.NewDecoder(xhttp2initialHeaderTableSize, nil)
	fr.MaxHeaderListSize = sc.maxHeaderListSize()
	fr.SetMaxReadFrameSize(s.maxReadFrameSize())
	sc.framer = fr

	if tc, ok := c.(xhttp2connectionStater); ok {
		sc.tlsState = new(tls.ConnectionState)
		*sc.tlsState = tc.ConnectionState()

		if sc.tlsState.Version < tls.VersionTLS12 {
			sc.rejectConn(xhttp2ErrCodeInadequateSecurity, "TLS version too low")
			return
		}

		if sc.tlsState.ServerName == "" {

		}

		if !s.PermitProhibitedCipherSuites && xhttp2isBadCipher(sc.tlsState.CipherSuite) {

			sc.rejectConn(xhttp2ErrCodeInadequateSecurity, fmt.Sprintf("Prohibited TLS 1.2 Cipher Suite: %x", sc.tlsState.CipherSuite))
			return
		}
	}

	if hook := xhttp2testHookGetServerConn; hook != nil {
		hook(sc)
	}
	sc.serve()
}

func (sc *xhttp2serverConn) rejectConn(err xhttp2ErrCode, debug string) {
	sc.vlogf("http2: server rejecting conn: %v, %s", err, debug)

	sc.framer.WriteGoAway(0, err, []byte(debug))
	sc.bw.Flush()
	sc.conn.Close()
}

type xhttp2serverConn struct {
	// Immutable:
	srv              *xhttp2Server
	hs               *http.Server
	conn             net.Conn
	bw               *xhttp2bufferedWriter // writing to conn
	handler          http.Handler
	baseCtx          xhttp2contextContext
	framer           *xhttp2Framer
	doneServing      chan struct{}                // closed when serverConn.serve ends
	readFrameCh      chan xhttp2readFrameResult   // written by serverConn.readFrames
	wantWriteFrameCh chan xhttp2FrameWriteRequest // from handlers -> serve
	wantStartPushCh  chan xhttp2startPushRequest  // from handlers -> serve
	wroteFrameCh     chan xhttp2frameWriteResult  // from writeFrameAsync -> serve, tickles more frame writes
	bodyReadCh       chan xhttp2bodyReadMsg       // from handlers -> serve
	testHookCh       chan func(int)               // code to run on the serve loop
	flow             xhttp2flow                   // conn-wide (not stream-specific) outbound flow control
	inflow           xhttp2flow                   // conn-wide inbound flow control
	tlsState         *tls.ConnectionState         // shared by all handlers, like net/http
	remoteAddrStr    string
	writeSched       xhttp2WriteScheduler

	// Everything following is owned by the serve loop; use serveG.check():
	serveG                xhttp2goroutineLock // used to verify funcs are on serve()
	pushEnabled           bool
	sawFirstSettings      bool // got the initial SETTINGS frame after the preface
	needToSendSettingsAck bool
	unackedSettings       int    // how many SETTINGS have we sent without ACKs?
	clientMaxStreams      uint32 // SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)
	advMaxStreams         uint32 // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client
	curClientStreams      uint32 // number of open streams initiated by the client
	curPushedStreams      uint32 // number of open streams initiated by server push
	maxClientStreamID     uint32 // max ever seen from client (odd), or 0 if there have been no client requests
	maxPushPromiseID      uint32 // ID of the last push promise (even), or 0 if there have been no pushes
	streams               map[uint32]*xhttp2stream
	initialWindowSize     int32
	maxFrameSize          int32
	headerTableSize       uint32
	peerMaxHeaderListSize uint32            // zero means unknown (default)
	canonHeader           map[string]string // http2-lower-case -> Go-Canonical-Case
	writingFrame          bool              // started writing a frame (on serve goroutine or separate)
	writingFrameAsync     bool              // started a frame on its own goroutine but haven't heard back on wroteFrameCh
	needsFrameFlush       bool              // last frame write wasn't a flush
	inGoAway              bool              // we've started to or sent GOAWAY
	inFrameScheduleLoop   bool              // whether we're in the scheduleFrameWrite loop
	needToSendGoAway      bool              // we need to schedule a GOAWAY frame write
	goAwayCode            xhttp2ErrCode
	shutdownTimerCh       <-chan time.Time // nil until used
	shutdownTimer         *time.Timer      // nil until used
	idleTimer             *time.Timer      // nil if unused
	idleTimerCh           <-chan time.Time // nil if unused

	// Owned by the writeFrameAsync goroutine:
	headerWriteBuf bytes.Buffer
	hpackEncoder   *hpack.Encoder
}

func (sc *xhttp2serverConn) maxHeaderListSize() uint32 {
	n := sc.hs.MaxHeaderBytes
	if n <= 0 {
		n = http.DefaultMaxHeaderBytes
	}
	// http2's count is in a slightly different unit and includes 32 bytes per pair.
	// So, take the net/http.Server value and pad it up a bit, assuming 10 headers.
	const perFieldOverhead = 32 // per http2 spec
	const typicalHeaders = 10   // conservative
	return uint32(n + typicalHeaders*perFieldOverhead)
}

func (sc *xhttp2serverConn) curOpenStreams() uint32 {
	sc.serveG.check()
	return sc.curClientStreams + sc.curPushedStreams
}

// stream represents a stream. This is the minimal metadata needed by
// the serve goroutine. Most of the actual stream state is owned by
// the http.Handler's goroutine in the responseWriter. Because the
// responseWriter's responseWriterState is recycled at the end of a
// handler, this struct intentionally has no pointer to the
// *responseWriter{,State} itself, as the Handler ending nils out the
// responseWriter's state field.
type xhttp2stream struct {
	// immutable:
	sc        *xhttp2serverConn
	id        uint32
	body      *xhttp2pipe       // non-nil if expecting DATA frames
	cw        xhttp2closeWaiter // closed wait stream transitions to closed state
	ctx       xhttp2contextContext
	cancelCtx func()

	// owned by serverConn's serve loop:
	bodyBytes        int64         // body bytes seen so far
	declBodyBytes    int64         // or -1 if undeclared
	flow             xhttp2flow    // limits writing from Handler to client
	inflow           xhttp2flow    // what the client is allowed to POST/etc to us
	parent           *xhttp2stream // or nil
	numTrailerValues int64
	weight           uint8
	state            xhttp2streamState
	sentReset        bool   // only true once detached from streams map
	gotReset         bool   // only true once detacted from streams map
	gotTrailerHeader bool   // HEADER frame for trailers was seen
	wroteHeaders     bool   // whether we wrote headers (not status 100)
	reqBuf           []byte // if non-nil, body pipe buffer to return later at EOF

	trailer    http.Header // accumulated trailers
	reqTrailer http.Header // handler's Request.Trailer
}

func (sc *xhttp2serverConn) Framer() *xhttp2Framer { return sc.framer }

func (sc *xhttp2serverConn) CloseConn() error { return sc.conn.Close() }

func (sc *xhttp2serverConn) Flush() error { return sc.bw.Flush() }

func (sc *xhttp2serverConn) HeaderEncoder() (*hpack.Encoder, *bytes.Buffer) {
	return sc.hpackEncoder, &sc.headerWriteBuf
}

func (sc *xhttp2serverConn) state(streamID uint32) (xhttp2streamState, *xhttp2stream) {
	sc.serveG.check()

	if st, ok := sc.streams[streamID]; ok {
		return st.state, st
	}

	if streamID%2 == 1 {
		if streamID <= sc.maxClientStreamID {
			return xhttp2stateClosed, nil
		}
	} else {
		if streamID <= sc.maxPushPromiseID {
			return xhttp2stateClosed, nil
		}
	}
	return xhttp2stateIdle, nil
}

// setConnState calls the net/http ConnState hook for this connection, if configured.
// Note that the net/http package does StateNew and StateClosed for us.
// There is currently no plan for StateHijacked or hijacking HTTP/2 connections.
func (sc *xhttp2serverConn) setConnState(state http.ConnState) {
	if sc.hs.ConnState != nil {
		sc.hs.ConnState(sc.conn, state)
	}
}

func (sc *xhttp2serverConn) vlogf(format string, args ...interface{}) {
	if xhttp2VerboseLogs {
		sc.logf(format, args...)
	}
}

func (sc *xhttp2serverConn) logf(format string, args ...interface{}) {
	if lg := sc.hs.ErrorLog; lg != nil {
		lg.Printf(format, args...)
	} else {
		log.Printf(format, args...)
	}
}

// errno returns v's underlying uintptr, else 0.
//
// TODO: remove this helper function once http2 can use build
// tags. See comment in isClosedConnError.
func xhttp2errno(v error) uintptr {
	if rv := reflect.ValueOf(v); rv.Kind() == reflect.Uintptr {
		return uintptr(rv.Uint())
	}
	return 0
}

// isClosedConnError reports whether err is an error from use of a closed
// network connection.
func xhttp2isClosedConnError(err error) bool {
	if err == nil {
		return false
	}

	str := err.Error()
	if strings.Contains(str, "use of closed network connection") {
		return true
	}

	if runtime.GOOS == "windows" {
		if oe, ok := err.(*net.OpError); ok && oe.Op == "read" {
			if se, ok := oe.Err.(*os.SyscallError); ok && se.Syscall == "wsarecv" {
				const WSAECONNABORTED = 10053
				const WSAECONNRESET = 10054
				if n := xhttp2errno(se.Err); n == WSAECONNRESET || n == WSAECONNABORTED {
					return true
				}
			}
		}
	}
	return false
}

func (sc *xhttp2serverConn) condlogf(err error, format string, args ...interface{}) {
	if err == nil {
		return
	}
	if err == io.EOF || err == io.ErrUnexpectedEOF || xhttp2isClosedConnError(err) {

		sc.vlogf(format, args...)
	} else {
		sc.logf(format, args...)
	}
}

func (sc *xhttp2serverConn) canonicalHeader(v string) string {
	sc.serveG.check()
	cv, ok := xhttp2commonCanonHeader[v]
	if ok {
		return cv
	}
	cv, ok = sc.canonHeader[v]
	if ok {
		return cv
	}
	if sc.canonHeader == nil {
		sc.canonHeader = make(map[string]string)
	}
	cv = http.CanonicalHeaderKey(v)
	sc.canonHeader[v] = cv
	return cv
}

type xhttp2readFrameResult struct {
	f   xhttp2Frame // valid until readMore is called
	err error

	// readMore should be called once the consumer no longer needs or
	// retains f. After readMore, f is invalid and more frames can be
	// read.
	readMore func()
}

// readFrames is the loop that reads incoming frames.
// It takes care to only read one frame at a time, blocking until the
// consumer is done with the frame.
// It's run on its own goroutine.
func (sc *xhttp2serverConn) readFrames() {
	gate := make(xhttp2gate)
	gateDone := gate.Done
	for {
		f, err := sc.framer.ReadFrame()
		select {
		case sc.readFrameCh <- xhttp2readFrameResult{f, err, gateDone}:
		case <-sc.doneServing:
			return
		}
		select {
		case <-gate:
		case <-sc.doneServing:
			return
		}
		if xhttp2terminalReadFrameError(err) {
			return
		}
	}
}

// frameWriteResult is the message passed from writeFrameAsync to the serve goroutine.
type xhttp2frameWriteResult struct {
	wr  xhttp2FrameWriteRequest // what was written (or attempted)
	err error                   // result of the writeFrame call
}

// writeFrameAsync runs in its own goroutine and writes a single frame
// and then reports when it's done.
// At most one goroutine can be running writeFrameAsync at a time per
// serverConn.
func (sc *xhttp2serverConn) writeFrameAsync(wr xhttp2FrameWriteRequest) {
	err := wr.write.writeFrame(sc)
	sc.wroteFrameCh <- xhttp2frameWriteResult{wr, err}
}

func (sc *xhttp2serverConn) closeAllStreamsOnConnClose() {
	sc.serveG.check()
	for _, st := range sc.streams {
		sc.closeStream(st, xhttp2errClientDisconnected)
	}
}

func (sc *xhttp2serverConn) stopShutdownTimer() {
	sc.serveG.check()
	if t := sc.shutdownTimer; t != nil {
		t.Stop()
	}
}

func (sc *xhttp2serverConn) notePanic() {

	if xhttp2testHookOnPanicMu != nil {
		xhttp2testHookOnPanicMu.Lock()
		defer xhttp2testHookOnPanicMu.Unlock()
	}
	if xhttp2testHookOnPanic != nil {
		if e := recover(); e != nil {
			if xhttp2testHookOnPanic(sc, e) {
				panic(e)
			}
		}
	}
}

func (sc *xhttp2serverConn) serve() {
	sc.serveG.check()
	defer sc.notePanic()
	defer sc.conn.Close()
	defer sc.closeAllStreamsOnConnClose()
	defer sc.stopShutdownTimer()
	defer close(sc.doneServing)

	if xhttp2VerboseLogs {
		sc.vlogf("http2: server connection from %v on %p", sc.conn.RemoteAddr(), sc.hs)
	}

	sc.writeFrame(xhttp2FrameWriteRequest{
		write: xhttp2writeSettings{
			{xhttp2SettingMaxFrameSize, sc.srv.maxReadFrameSize()},
			{xhttp2SettingMaxConcurrentStreams, sc.advMaxStreams},
			{xhttp2SettingMaxHeaderListSize, sc.maxHeaderListSize()},
		},
	})
	sc.unackedSettings++

	if err := sc.readPreface(); err != nil {
		sc.condlogf(err, "http2: server: error reading preface from client %v: %v", sc.conn.RemoteAddr(), err)
		return
	}

	sc.setConnState(http.StateActive)
	sc.setConnState(http.StateIdle)

	if sc.srv.IdleTimeout != 0 {
		sc.idleTimer = time.NewTimer(sc.srv.IdleTimeout)
		defer sc.idleTimer.Stop()
		sc.idleTimerCh = sc.idleTimer.C
	}

	var gracefulShutdownCh <-chan struct{}
	if sc.hs != nil {
		gracefulShutdownCh = xhttp2h1ServerShutdownChan(sc.hs)
	}

	go sc.readFrames()

	settingsTimer := time.NewTimer(xhttp2firstSettingsTimeout)
	loopNum := 0
	for {
		loopNum++
		select {
		case wr := <-sc.wantWriteFrameCh:
			sc.writeFrame(wr)
		case spr := <-sc.wantStartPushCh:
			sc.startPush(spr)
		case res := <-sc.wroteFrameCh:
			sc.wroteFrame(res)
		case res := <-sc.readFrameCh:
			if !sc.processFrameFromReader(res) {
				return
			}
			res.readMore()
			if settingsTimer.C != nil {
				settingsTimer.Stop()
				settingsTimer.C = nil
			}
		case m := <-sc.bodyReadCh:
			sc.noteBodyRead(m.st, m.n)
		case <-settingsTimer.C:
			sc.logf("timeout waiting for SETTINGS frames from %v", sc.conn.RemoteAddr())
			return
		case <-gracefulShutdownCh:
			gracefulShutdownCh = nil
			sc.startGracefulShutdown()
		case <-sc.shutdownTimerCh:
			sc.vlogf("GOAWAY close timer fired; closing conn from %v", sc.conn.RemoteAddr())
			return
		case <-sc.idleTimerCh:
			sc.vlogf("connection is idle")
			sc.goAway(xhttp2ErrCodeNo)
		case fn := <-sc.testHookCh:
			fn(loopNum)
		}

		if sc.inGoAway && sc.curOpenStreams() == 0 && !sc.needToSendGoAway && !sc.writingFrame {
			return
		}
	}
}

// readPreface reads the ClientPreface greeting from the peer
// or returns an error on timeout or an invalid greeting.
func (sc *xhttp2serverConn) readPreface() error {
	errc := make(chan error, 1)
	go func() {

		buf := make([]byte, len(xhttp2ClientPreface))
		if _, err := io.ReadFull(sc.conn, buf); err != nil {
			errc <- err
		} else if !bytes.Equal(buf, xhttp2clientPreface) {
			errc <- fmt.Errorf("bogus greeting %q", buf)
		} else {
			errc <- nil
		}
	}()
	timer := time.NewTimer(xhttp2prefaceTimeout)
	defer timer.Stop()
	select {
	case <-timer.C:
		return errors.New("timeout waiting for client preface")
	case err := <-errc:
		if err == nil {
			if xhttp2VerboseLogs {
				sc.vlogf("http2: server: client %v said hello", sc.conn.RemoteAddr())
			}
		}
		return err
	}
}

var xhttp2errChanPool = sync.Pool{
	New: func() interface{} { return make(chan error, 1) },
}

var xhttp2writeDataPool = sync.Pool{
	New: func() interface{} { return new(xhttp2writeData) },
}

// writeDataFromHandler writes DATA response frames from a handler on
// the given stream.
func (sc *xhttp2serverConn) writeDataFromHandler(stream *xhttp2stream, data []byte, endStream bool) error {
	ch := xhttp2errChanPool.Get().(chan error)
	writeArg := xhttp2writeDataPool.Get().(*xhttp2writeData)
	*writeArg = xhttp2writeData{stream.id, data, endStream}
	err := sc.writeFrameFromHandler(xhttp2FrameWriteRequest{
		write:  writeArg,
		stream: stream,
		done:   ch,
	})
	if err != nil {
		return err
	}
	var frameWriteDone bool // the frame write is done (successfully or not)
	select {
	case err = <-ch:
		frameWriteDone = true
	case <-sc.doneServing:
		return xhttp2errClientDisconnected
	case <-stream.cw:

		select {
		case err = <-ch:
			frameWriteDone = true
		default:
			return xhttp2errStreamClosed
		}
	}
	xhttp2errChanPool.Put(ch)
	if frameWriteDone {
		xhttp2writeDataPool.Put(writeArg)
	}
	return err
}

// writeFrameFromHandler sends wr to sc.wantWriteFrameCh, but aborts
// if the connection has gone away.
//
// This must not be run from the serve goroutine itself, else it might
// deadlock writing to sc.wantWriteFrameCh (which is only mildly
// buffered and is read by serve itself). If you're on the serve
// goroutine, call writeFrame instead.
func (sc *xhttp2serverConn) writeFrameFromHandler(wr xhttp2FrameWriteRequest) error {
	sc.serveG.checkNotOn()
	select {
	case sc.wantWriteFrameCh <- wr:
		return nil
	case <-sc.doneServing:

		return xhttp2errClientDisconnected
	}
}

// writeFrame schedules a frame to write and sends it if there's nothing
// already being written.
//
// There is no pushback here (the serve goroutine never blocks). It's
// the http.Handlers that block, waiting for their previous frames to
// make it onto the wire
//
// If you're not on the serve goroutine, use writeFrameFromHandler instead.
func (sc *xhttp2serverConn) writeFrame(wr xhttp2FrameWriteRequest) {
	sc.serveG.check()

	var ignoreWrite bool

	switch wr.write.(type) {
	case *xhttp2writeResHeaders:
		wr.stream.wroteHeaders = true
	case xhttp2write100ContinueHeadersFrame:
		if wr.stream.wroteHeaders {
			ignoreWrite = true
		}
	}

	if !ignoreWrite {
		sc.writeSched.Push(wr)
	}
	sc.scheduleFrameWrite()
}

// startFrameWrite starts a goroutine to write wr (in a separate
// goroutine since that might block on the network), and updates the
// serve goroutine's state about the world, updated from info in wr.
func (sc *xhttp2serverConn) startFrameWrite(wr xhttp2FrameWriteRequest) {
	sc.serveG.check()
	if sc.writingFrame {
		panic("internal error: can only be writing one frame at a time")
	}

	st := wr.stream
	if st != nil {
		switch st.state {
		case xhttp2stateHalfClosedLocal:
			panic("internal error: attempt to send frame on half-closed-local stream")
		case xhttp2stateClosed:
			if st.sentReset || st.gotReset {

				sc.scheduleFrameWrite()
				return
			}
			panic(fmt.Sprintf("internal error: attempt to send a write %v on a closed stream", wr))
		}
	}
	if wpp, ok := wr.write.(*xhttp2writePushPromise); ok {
		var err error
		wpp.promisedID, err = wpp.allocatePromisedID()
		if err != nil {
			sc.writingFrameAsync = false
			if wr.done != nil {
				wr.done <- err
			}
			return
		}
	}

	sc.writingFrame = true
	sc.needsFrameFlush = true
	if wr.write.staysWithinBuffer(sc.bw.Available()) {
		sc.writingFrameAsync = false
		err := wr.write.writeFrame(sc)
		sc.wroteFrame(xhttp2frameWriteResult{wr, err})
	} else {
		sc.writingFrameAsync = true
		go sc.writeFrameAsync(wr)
	}
}

// errHandlerPanicked is the error given to any callers blocked in a read from
// Request.Body when the main goroutine panics. Since most handlers read in the
// the main ServeHTTP goroutine, this will show up rarely.
var xhttp2errHandlerPanicked = errors.New("http2: handler panicked")

// wroteFrame is called on the serve goroutine with the result of
// whatever happened on writeFrameAsync.
func (sc *xhttp2serverConn) wroteFrame(res xhttp2frameWriteResult) {
	sc.serveG.check()
	if !sc.writingFrame {
		panic("internal error: expected to be already writing a frame")
	}
	sc.writingFrame = false
	sc.writingFrameAsync = false

	wr := res.wr
	st := wr.stream

	closeStream := xhttp2endsStream(wr.write)

	if _, ok := wr.write.(xhttp2handlerPanicRST); ok {
		sc.closeStream(st, xhttp2errHandlerPanicked)
	}

	if ch := wr.done; ch != nil {
		select {
		case ch <- res.err:
		default:
			panic(fmt.Sprintf("unbuffered done channel passed in for type %T", wr.write))
		}
	}
	wr.write = nil

	if closeStream {
		if st == nil {
			panic("internal error: expecting non-nil stream")
		}
		switch st.state {
		case xhttp2stateOpen:

			st.state = xhttp2stateHalfClosedLocal
			errCancel := xhttp2streamError(st.id, xhttp2ErrCodeCancel)
			sc.resetStream(errCancel)
		case xhttp2stateHalfClosedRemote:
			sc.closeStream(st, xhttp2errHandlerComplete)
		}
	}

	sc.scheduleFrameWrite()
}

// scheduleFrameWrite tickles the frame writing scheduler.
//
// If a frame is already being written, nothing happens. This will be called again
// when the frame is done being written.
//
// If a frame isn't being written we need to send one, the best frame
// to send is selected, preferring first things that aren't
// stream-specific (e.g. ACKing settings), and then finding the
// highest priority stream.
//
// If a frame isn't being written and there's nothing else to send, we
// flush the write buffer.
func (sc *xhttp2serverConn) scheduleFrameWrite() {
	sc.serveG.check()
	if sc.writingFrame || sc.inFrameScheduleLoop {
		return
	}
	sc.inFrameScheduleLoop = true
	for !sc.writingFrameAsync {
		if sc.needToSendGoAway {
			sc.needToSendGoAway = false
			sc.startFrameWrite(xhttp2FrameWriteRequest{
				write: &xhttp2writeGoAway{
					maxStreamID: sc.maxClientStreamID,
					code:        sc.goAwayCode,
				},
			})
			continue
		}
		if sc.needToSendSettingsAck {
			sc.needToSendSettingsAck = false
			sc.startFrameWrite(xhttp2FrameWriteRequest{write: xhttp2writeSettingsAck{}})
			continue
		}
		if !sc.inGoAway || sc.goAwayCode == xhttp2ErrCodeNo {
			if wr, ok := sc.writeSched.Pop(); ok {
				sc.startFrameWrite(wr)
				continue
			}
		}
		if sc.needsFrameFlush {
			sc.startFrameWrite(xhttp2FrameWriteRequest{write: xhttp2flushFrameWriter{}})
			sc.needsFrameFlush = false
			continue
		}
		break
	}
	sc.inFrameScheduleLoop = false
}

// startGracefulShutdown sends a GOAWAY with ErrCodeNo to tell the
// client we're gracefully shutting down. The connection isn't closed
// until all current streams are done.
func (sc *xhttp2serverConn) startGracefulShutdown() {
	sc.goAwayIn(xhttp2ErrCodeNo, 0)
}

func (sc *xhttp2serverConn) goAway(code xhttp2ErrCode) {
	sc.serveG.check()
	var forceCloseIn time.Duration
	if code != xhttp2ErrCodeNo {
		forceCloseIn = 250 * time.Millisecond
	} else {

		forceCloseIn = 1 * time.Second
	}
	sc.goAwayIn(code, forceCloseIn)
}

func (sc *xhttp2serverConn) goAwayIn(code xhttp2ErrCode, forceCloseIn time.Duration) {
	sc.serveG.check()
	if sc.inGoAway {
		return
	}
	if forceCloseIn != 0 {
		sc.shutDownIn(forceCloseIn)
	}
	sc.inGoAway = true
	sc.needToSendGoAway = true
	sc.goAwayCode = code
	sc.scheduleFrameWrite()
}

func (sc *xhttp2serverConn) shutDownIn(d time.Duration) {
	sc.serveG.check()
	sc.shutdownTimer = time.NewTimer(d)
	sc.shutdownTimerCh = sc.shutdownTimer.C
}

func (sc *xhttp2serverConn) resetStream(se xhttp2StreamError) {
	sc.serveG.check()
	sc.writeFrame(xhttp2FrameWriteRequest{write: se})
	if st, ok := sc.streams[se.StreamID]; ok {
		st.sentReset = true
		sc.closeStream(st, se)
	}
}

// processFrameFromReader processes the serve loop's read from readFrameCh from the
// frame-reading goroutine.
// processFrameFromReader returns whether the connection should be kept open.
func (sc *xhttp2serverConn) processFrameFromReader(res xhttp2readFrameResult) bool {
	sc.serveG.check()
	err := res.err
	if err != nil {
		if err == xhttp2ErrFrameTooLarge {
			sc.goAway(xhttp2ErrCodeFrameSize)
			return true
		}
		clientGone := err == io.EOF || err == io.ErrUnexpectedEOF || xhttp2isClosedConnError(err)
		if clientGone {

			return false
		}
	} else {
		f := res.f
		if xhttp2VerboseLogs {
			sc.vlogf("http2: server read frame %v", xhttp2summarizeFrame(f))
		}
		err = sc.processFrame(f)
		if err == nil {
			return true
		}
	}

	switch ev := err.(type) {
	case xhttp2StreamError:
		sc.resetStream(ev)
		return true
	case xhttp2goAwayFlowError:
		sc.goAway(xhttp2ErrCodeFlowControl)
		return true
	case xhttp2ConnectionError:
		sc.logf("http2: server connection error from %v: %v", sc.conn.RemoteAddr(), ev)
		sc.goAway(xhttp2ErrCode(ev))
		return true
	default:
		if res.err != nil {
			sc.vlogf("http2: server closing client connection; error reading frame from client %s: %v", sc.conn.RemoteAddr(), err)
		} else {
			sc.logf("http2: server closing client connection: %v", err)
		}
		return false
	}
}

func (sc *xhttp2serverConn) processFrame(f xhttp2Frame) error {
	sc.serveG.check()

	if !sc.sawFirstSettings {
		if _, ok := f.(*xhttp2SettingsFrame); !ok {
			return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
		}
		sc.sawFirstSettings = true
	}

	switch f := f.(type) {
	case *xhttp2SettingsFrame:
		return sc.processSettings(f)
	case *xhttp2MetaHeadersFrame:
		return sc.processHeaders(f)
	case *xhttp2WindowUpdateFrame:
		return sc.processWindowUpdate(f)
	case *xhttp2PingFrame:
		return sc.processPing(f)
	case *xhttp2DataFrame:
		return sc.processData(f)
	case *xhttp2RSTStreamFrame:
		return sc.processResetStream(f)
	case *xhttp2PriorityFrame:
		return sc.processPriority(f)
	case *xhttp2GoAwayFrame:
		return sc.processGoAway(f)
	case *xhttp2PushPromiseFrame:

		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	default:
		sc.vlogf("http2: server ignoring frame: %v", f.Header())
		return nil
	}
}

func (sc *xhttp2serverConn) processPing(f *xhttp2PingFrame) error {
	sc.serveG.check()
	if f.IsAck() {

		return nil
	}
	if f.StreamID != 0 {

		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	if sc.inGoAway && sc.goAwayCode != xhttp2ErrCodeNo {
		return nil
	}
	sc.writeFrame(xhttp2FrameWriteRequest{write: xhttp2writePingAck{f}})
	return nil
}

func (sc *xhttp2serverConn) processWindowUpdate(f *xhttp2WindowUpdateFrame) error {
	sc.serveG.check()
	switch {
	case f.StreamID != 0:
		state, st := sc.state(f.StreamID)
		if state == xhttp2stateIdle {

			return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
		}
		if st == nil {

			return nil
		}
		if !st.flow.add(int32(f.Increment)) {
			return xhttp2streamError(f.StreamID, xhttp2ErrCodeFlowControl)
		}
	default:
		if !sc.flow.add(int32(f.Increment)) {
			return xhttp2goAwayFlowError{}
		}
	}
	sc.scheduleFrameWrite()
	return nil
}

func (sc *xhttp2serverConn) processResetStream(f *xhttp2RSTStreamFrame) error {
	sc.serveG.check()

	state, st := sc.state(f.StreamID)
	if state == xhttp2stateIdle {

		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	if st != nil {
		st.gotReset = true
		st.cancelCtx()
		sc.closeStream(st, xhttp2streamError(f.StreamID, f.ErrCode))
	}
	return nil
}

func (sc *xhttp2serverConn) closeStream(st *xhttp2stream, err error) {
	sc.serveG.check()
	if st.state == xhttp2stateIdle || st.state == xhttp2stateClosed {
		panic(fmt.Sprintf("invariant; can't close stream in state %v", st.state))
	}
	st.state = xhttp2stateClosed
	if st.isPushed() {
		sc.curPushedStreams--
	} else {
		sc.curClientStreams--
	}
	delete(sc.streams, st.id)
	if len(sc.streams) == 0 {
		sc.setConnState(http.StateIdle)
		if sc.srv.IdleTimeout != 0 {
			sc.idleTimer.Reset(sc.srv.IdleTimeout)
		}
		if xhttp2h1ServerKeepAlivesDisabled(sc.hs) {
			sc.startGracefulShutdown()
		}
	}
	if p := st.body; p != nil {

		sc.sendWindowUpdate(nil, p.Len())

		p.CloseWithError(err)
	}
	st.cw.Close()
	sc.writeSched.CloseStream(st.id)
}

func (sc *xhttp2serverConn) processSettings(f *xhttp2SettingsFrame) error {
	sc.serveG.check()
	if f.IsAck() {
		sc.unackedSettings--
		if sc.unackedSettings < 0 {

			return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
		}
		return nil
	}
	if err := f.ForeachSetting(sc.processSetting); err != nil {
		return err
	}
	sc.needToSendSettingsAck = true
	sc.scheduleFrameWrite()
	return nil
}

func (sc *xhttp2serverConn) processSetting(s xhttp2Setting) error {
	sc.serveG.check()
	if err := s.Valid(); err != nil {
		return err
	}
	if xhttp2VerboseLogs {
		sc.vlogf("http2: server processing setting %v", s)
	}
	switch s.ID {
	case xhttp2SettingHeaderTableSize:
		sc.headerTableSize = s.Val
		sc.hpackEncoder.SetMaxDynamicTableSize(s.Val)
	case xhttp2SettingEnablePush:
		sc.pushEnabled = s.Val != 0
	case xhttp2SettingMaxConcurrentStreams:
		sc.clientMaxStreams = s.Val
	case xhttp2SettingInitialWindowSize:
		return sc.processSettingInitialWindowSize(s.Val)
	case xhttp2SettingMaxFrameSize:
		sc.maxFrameSize = int32(s.Val)
	case xhttp2SettingMaxHeaderListSize:
		sc.peerMaxHeaderListSize = s.Val
	default:

		if xhttp2VerboseLogs {
			sc.vlogf("http2: server ignoring unknown setting %v", s)
		}
	}
	return nil
}

func (sc *xhttp2serverConn) processSettingInitialWindowSize(val uint32) error {
	sc.serveG.check()

	old := sc.initialWindowSize
	sc.initialWindowSize = int32(val)
	growth := sc.initialWindowSize - old
	for _, st := range sc.streams {
		if !st.flow.add(growth) {

			return xhttp2ConnectionError(xhttp2ErrCodeFlowControl)
		}
	}
	return nil
}

func (sc *xhttp2serverConn) processData(f *xhttp2DataFrame) error {
	sc.serveG.check()
	if sc.inGoAway && sc.goAwayCode != xhttp2ErrCodeNo {
		return nil
	}
	data := f.Data()

	id := f.Header().StreamID
	state, st := sc.state(id)
	if id == 0 || state == xhttp2stateIdle {

		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	if st == nil || state != xhttp2stateOpen || st.gotTrailerHeader {

		if sc.inflow.available() < int32(f.Length) {
			return xhttp2streamError(id, xhttp2ErrCodeFlowControl)
		}

		sc.inflow.take(int32(f.Length))
		sc.sendWindowUpdate(nil, int(f.Length))

		return xhttp2streamError(id, xhttp2ErrCodeStreamClosed)
	}
	if st.body == nil {
		panic("internal error: should have a body in this state")
	}

	if st.declBodyBytes != -1 && st.bodyBytes+int64(len(data)) > st.declBodyBytes {
		st.body.CloseWithError(fmt.Errorf("sender tried to send more than declared Content-Length of %d bytes", st.declBodyBytes))
		return xhttp2streamError(id, xhttp2ErrCodeStreamClosed)
	}
	if f.Length > 0 {

		if st.inflow.available() < int32(f.Length) {
			return xhttp2streamError(id, xhttp2ErrCodeFlowControl)
		}
		st.inflow.take(int32(f.Length))

		if len(data) > 0 {
			wrote, err := st.body.Write(data)
			if err != nil {
				return xhttp2streamError(id, xhttp2ErrCodeStreamClosed)
			}
			if wrote != len(data) {
				panic("internal error: bad Writer")
			}
			st.bodyBytes += int64(len(data))
		}

		if pad := int32(f.Length) - int32(len(data)); pad > 0 {
			sc.sendWindowUpdate32(nil, pad)
			sc.sendWindowUpdate32(st, pad)
		}
	}
	if f.StreamEnded() {
		st.endStream()
	}
	return nil
}

func (sc *xhttp2serverConn) processGoAway(f *xhttp2GoAwayFrame) error {
	sc.serveG.check()
	if f.ErrCode != xhttp2ErrCodeNo {
		sc.logf("http2: received GOAWAY %+v, starting graceful shutdown", f)
	} else {
		sc.vlogf("http2: received GOAWAY %+v, starting graceful shutdown", f)
	}
	sc.startGracefulShutdown()

	sc.pushEnabled = false
	return nil
}

// isPushed reports whether the stream is server-initiated.
func (st *xhttp2stream) isPushed() bool {
	return st.id%2 == 0
}

// endStream closes a Request.Body's pipe. It is called when a DATA
// frame says a request body is over (or after trailers).
func (st *xhttp2stream) endStream() {
	sc := st.sc
	sc.serveG.check()

	if st.declBodyBytes != -1 && st.declBodyBytes != st.bodyBytes {
		st.body.CloseWithError(fmt.Errorf("request declared a Content-Length of %d but only wrote %d bytes",
			st.declBodyBytes, st.bodyBytes))
	} else {
		st.body.closeWithErrorAndCode(io.EOF, st.copyTrailersToHandlerRequest)
		st.body.CloseWithError(io.EOF)
	}
	st.state = xhttp2stateHalfClosedRemote
}

// copyTrailersToHandlerRequest is run in the Handler's goroutine in
// its Request.Body.Read just before it gets io.EOF.
func (st *xhttp2stream) copyTrailersToHandlerRequest() {
	for k, vv := range st.trailer {
		if _, ok := st.reqTrailer[k]; ok {

			st.reqTrailer[k] = vv
		}
	}
}

func (sc *xhttp2serverConn) processHeaders(f *xhttp2MetaHeadersFrame) error {
	sc.serveG.check()
	id := f.StreamID
	if sc.inGoAway {

		return nil
	}

	if id%2 != 1 {
		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}

	if st := sc.streams[f.StreamID]; st != nil {
		return st.processTrailerHeaders(f)
	}

	if id <= sc.maxClientStreamID {
		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	sc.maxClientStreamID = id

	if sc.idleTimer != nil {
		sc.idleTimer.Stop()
	}

	if sc.curClientStreams+1 > sc.advMaxStreams {
		if sc.unackedSettings == 0 {

			return xhttp2streamError(id, xhttp2ErrCodeProtocol)
		}

		return xhttp2streamError(id, xhttp2ErrCodeRefusedStream)
	}

	initialState := xhttp2stateOpen
	if f.StreamEnded() {
		initialState = xhttp2stateHalfClosedRemote
	}
	st := sc.newStream(id, 0, initialState)

	if f.HasPriority() {
		if err := xhttp2checkPriority(f.StreamID, f.Priority); err != nil {
			return err
		}
		sc.writeSched.AdjustStream(st.id, f.Priority)
	}

	rw, req, err := sc.newWriterAndRequest(st, f)
	if err != nil {
		return err
	}
	st.reqTrailer = req.Trailer
	if st.reqTrailer != nil {
		st.trailer = make(http.Header)
	}
	st.body = req.Body.(*xhttp2requestBody).pipe
	st.declBodyBytes = req.ContentLength

	handler := sc.handler.ServeHTTP
	if f.Truncated {

		handler = xhttp2handleHeaderListTooLong
	} else if err := xhttp2checkValidHTTP2RequestHeaders(req.Header); err != nil {
		handler = xhttp2new400Handler(err)
	}

	if sc.hs.ReadTimeout != 0 {
		sc.conn.SetReadDeadline(time.Time{})
	}

	go sc.runHandler(rw, req, handler)
	return nil
}

func (st *xhttp2stream) processTrailerHeaders(f *xhttp2MetaHeadersFrame) error {
	sc := st.sc
	sc.serveG.check()
	if st.gotTrailerHeader {
		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	st.gotTrailerHeader = true
	if !f.StreamEnded() {
		return xhttp2streamError(st.id, xhttp2ErrCodeProtocol)
	}

	if len(f.PseudoFields()) > 0 {
		return xhttp2streamError(st.id, xhttp2ErrCodeProtocol)
	}
	if st.trailer != nil {
		for _, hf := range f.RegularFields() {
			key := sc.canonicalHeader(hf.Name)
			if !xhttp2ValidTrailerHeader(key) {

				return xhttp2streamError(st.id, xhttp2ErrCodeProtocol)
			}
			st.trailer[key] = append(st.trailer[key], hf.Value)
		}
	}
	st.endStream()
	return nil
}

func xhttp2checkPriority(streamID uint32, p xhttp2PriorityParam) error {
	if streamID == p.StreamDep {

		return xhttp2streamError(streamID, xhttp2ErrCodeProtocol)
	}
	return nil
}

func (sc *xhttp2serverConn) processPriority(f *xhttp2PriorityFrame) error {
	if sc.inGoAway {
		return nil
	}
	if err := xhttp2checkPriority(f.StreamID, f.xhttp2PriorityParam); err != nil {
		return err
	}
	sc.writeSched.AdjustStream(f.StreamID, f.xhttp2PriorityParam)
	return nil
}

func (sc *xhttp2serverConn) newStream(id, pusherID uint32, state xhttp2streamState) *xhttp2stream {
	sc.serveG.check()
	if id == 0 {
		panic("internal error: cannot create stream with id 0")
	}

	ctx, cancelCtx := xhttp2contextWithCancel(sc.baseCtx)
	st := &xhttp2stream{
		sc:        sc,
		id:        id,
		state:     state,
		ctx:       ctx,
		cancelCtx: cancelCtx,
	}
	st.cw.Init()
	st.flow.conn = &sc.flow
	st.flow.add(sc.initialWindowSize)
	st.inflow.conn = &sc.inflow
	st.inflow.add(xhttp2initialWindowSize)

	sc.streams[id] = st
	sc.writeSched.OpenStream(st.id, xhttp2OpenStreamOptions{PusherID: pusherID})
	if st.isPushed() {
		sc.curPushedStreams++
	} else {
		sc.curClientStreams++
	}
	if sc.curOpenStreams() == 1 {
		sc.setConnState(http.StateActive)
	}

	return st
}

func (sc *xhttp2serverConn) newWriterAndRequest(st *xhttp2stream, f *xhttp2MetaHeadersFrame) (*xhttp2responseWriter, *http.Request, error) {
	sc.serveG.check()

	rp := xhttp2requestParam{
		method:    f.PseudoValue("method"),
		scheme:    f.PseudoValue("scheme"),
		authority: f.PseudoValue("authority"),
		path:      f.PseudoValue("path"),
	}

	isConnect := rp.method == "CONNECT"
	if isConnect {
		if rp.path != "" || rp.scheme != "" || rp.authority == "" {
			return nil, nil, xhttp2streamError(f.StreamID, xhttp2ErrCodeProtocol)
		}
	} else if rp.method == "" || rp.path == "" || (rp.scheme != "https" && rp.scheme != "http") {

		return nil, nil, xhttp2streamError(f.StreamID, xhttp2ErrCodeProtocol)
	}

	bodyOpen := !f.StreamEnded()
	if rp.method == "HEAD" && bodyOpen {

		return nil, nil, xhttp2streamError(f.StreamID, xhttp2ErrCodeProtocol)
	}

	rp.header = make(http.Header)
	for _, hf := range f.RegularFields() {
		rp.header.Add(sc.canonicalHeader(hf.Name), hf.Value)
	}
	if rp.authority == "" {
		rp.authority = rp.header.Get("Host")
	}

	rw, req, err := sc.newWriterAndRequestNoBody(st, rp)
	if err != nil {
		return nil, nil, err
	}
	if bodyOpen {
		st.reqBuf = xhttp2getRequestBodyBuf()
		req.Body.(*xhttp2requestBody).pipe = &xhttp2pipe{
			b: &xhttp2fixedBuffer{buf: st.reqBuf},
		}

		if vv, ok := rp.header["Content-Length"]; ok {
			req.ContentLength, _ = strconv.ParseInt(vv[0], 10, 64)
		} else {
			req.ContentLength = -1
		}
	}
	return rw, req, nil
}

type xhttp2requestParam struct {
	method                  string
	scheme, authority, path string
	header                  http.Header
}

func (sc *xhttp2serverConn) newWriterAndRequestNoBody(st *xhttp2stream, rp xhttp2requestParam) (*xhttp2responseWriter, *http.Request, error) {
	sc.serveG.check()

	var tlsState *tls.ConnectionState // nil if not scheme https
	if rp.scheme == "https" {
		tlsState = sc.tlsState
	}

	needsContinue := rp.header.Get("Expect") == "100-continue"
	if needsContinue {
		rp.header.Del("Expect")
	}

	if cookies := rp.header["Cookie"]; len(cookies) > 1 {
		rp.header.Set("Cookie", strings.Join(cookies, "; "))
	}

	// Setup Trailers
	var trailer http.Header
	for _, v := range rp.header["Trailer"] {
		for _, key := range strings.Split(v, ",") {
			key = http.CanonicalHeaderKey(strings.TrimSpace(key))
			switch key {
			case "Transfer-Encoding", "Trailer", "Content-Length":

			default:
				if trailer == nil {
					trailer = make(http.Header)
				}
				trailer[key] = nil
			}
		}
	}
	delete(rp.header, "Trailer")

	var url_ *url.URL
	var requestURI string
	if rp.method == "CONNECT" {
		url_ = &url.URL{Host: rp.authority}
		requestURI = rp.authority
	} else {
		var err error
		url_, err = url.ParseRequestURI(rp.path)
		if err != nil {
			return nil, nil, xhttp2streamError(st.id, xhttp2ErrCodeProtocol)
		}
		requestURI = rp.path
	}

	body := &xhttp2requestBody{
		conn:          sc,
		stream:        st,
		needsContinue: needsContinue,
	}
	req := &http.Request{
		Method:     rp.method,
		URL:        url_,
		RemoteAddr: sc.remoteAddrStr,
		Header:     rp.header,
		RequestURI: requestURI,
		Proto:      "HTTP/2.0",
		ProtoMajor: 2,
		ProtoMinor: 0,
		TLS:        tlsState,
		Host:       rp.authority,
		Body:       body,
		Trailer:    trailer,
	}
	req = xhttp2requestWithContext(req, st.ctx)

	rws := xhttp2responseWriterStatePool.Get().(*xhttp2responseWriterState)
	bwSave := rws.bw
	*rws = xhttp2responseWriterState{}
	rws.conn = sc
	rws.bw = bwSave
	rws.bw.Reset(xhttp2chunkWriter{rws})
	rws.stream = st
	rws.req = req
	rws.body = body

	rw := &xhttp2responseWriter{rws: rws}
	return rw, req, nil
}

var xhttp2reqBodyCache = make(chan []byte, 8)

func xhttp2getRequestBodyBuf() []byte {
	select {
	case b := <-xhttp2reqBodyCache:
		return b
	default:
		return make([]byte, xhttp2initialWindowSize)
	}
}

func xhttp2putRequestBodyBuf(b []byte) {
	select {
	case xhttp2reqBodyCache <- b:
	default:
	}
}

// Run on its own goroutine.
func (sc *xhttp2serverConn) runHandler(rw *xhttp2responseWriter, req *http.Request, handler func(http.ResponseWriter, *http.Request)) {
	didPanic := true
	defer func() {
		rw.rws.stream.cancelCtx()
		if didPanic {
			e := recover()
			sc.writeFrameFromHandler(xhttp2FrameWriteRequest{
				write:  xhttp2handlerPanicRST{rw.rws.stream.id},
				stream: rw.rws.stream,
			})

			if xhttp2shouldLogPanic(e) {
				const size = 64 << 10
				buf := make([]byte, size)
				buf = buf[:runtime.Stack(buf, false)]
				sc.logf("http2: panic serving %v: %v\n%s", sc.conn.RemoteAddr(), e, buf)
			}
			return
		}
		rw.handlerDone()
	}()
	handler(rw, req)
	didPanic = false
}

func xhttp2handleHeaderListTooLong(w http.ResponseWriter, r *http.Request) {
	// 10.5.1 Limits on Header Block Size:
	// .. "A server that receives a larger header block than it is
	// willing to handle can send an HTTP 431 (Request Header Fields Too
	// Large) status code"
	const statusRequestHeaderFieldsTooLarge = 431 // only in Go 1.6+
	w.WriteHeader(statusRequestHeaderFieldsTooLarge)
	io.WriteString(w, "<h1>HTTP Error 431</h1><p>Request Header Field(s) Too Large</p>")
}

// called from handler goroutines.
// h may be nil.
func (sc *xhttp2serverConn) writeHeaders(st *xhttp2stream, headerData *xhttp2writeResHeaders) error {
	sc.serveG.checkNotOn()
	var errc chan error
	if headerData.h != nil {

		errc = xhttp2errChanPool.Get().(chan error)
	}
	if err := sc.writeFrameFromHandler(xhttp2FrameWriteRequest{
		write:  headerData,
		stream: st,
		done:   errc,
	}); err != nil {
		return err
	}
	if errc != nil {
		select {
		case err := <-errc:
			xhttp2errChanPool.Put(errc)
			return err
		case <-sc.doneServing:
			return xhttp2errClientDisconnected
		case <-st.cw:
			return xhttp2errStreamClosed
		}
	}
	return nil
}

// called from handler goroutines.
func (sc *xhttp2serverConn) write100ContinueHeaders(st *xhttp2stream) {
	sc.writeFrameFromHandler(xhttp2FrameWriteRequest{
		write:  xhttp2write100ContinueHeadersFrame{st.id},
		stream: st,
	})
}

// A bodyReadMsg tells the server loop that the http.Handler read n
// bytes of the DATA from the client on the given stream.
type xhttp2bodyReadMsg struct {
	st *xhttp2stream
	n  int
}

// called from handler goroutines.
// Notes that the handler for the given stream ID read n bytes of its body
// and schedules flow control tokens to be sent.
func (sc *xhttp2serverConn) noteBodyReadFromHandler(st *xhttp2stream, n int, err error) {
	sc.serveG.checkNotOn()
	if n > 0 {
		select {
		case sc.bodyReadCh <- xhttp2bodyReadMsg{st, n}:
		case <-sc.doneServing:
		}
	}
	if err == io.EOF {
		if buf := st.reqBuf; buf != nil {
			st.reqBuf = nil
			xhttp2putRequestBodyBuf(buf)
		}
	}
}

func (sc *xhttp2serverConn) noteBodyRead(st *xhttp2stream, n int) {
	sc.serveG.check()
	sc.sendWindowUpdate(nil, n)
	if st.state != xhttp2stateHalfClosedRemote && st.state != xhttp2stateClosed {

		sc.sendWindowUpdate(st, n)
	}
}

// st may be nil for conn-level
func (sc *xhttp2serverConn) sendWindowUpdate(st *xhttp2stream, n int) {
	sc.serveG.check()
	// "The legal range for the increment to the flow control
	// window is 1 to 2^31-1 (2,147,483,647) octets."
	// A Go Read call on 64-bit machines could in theory read
	// a larger Read than this. Very unlikely, but we handle it here
	// rather than elsewhere for now.
	const maxUint31 = 1<<31 - 1
	for n >= maxUint31 {
		sc.sendWindowUpdate32(st, maxUint31)
		n -= maxUint31
	}
	sc.sendWindowUpdate32(st, int32(n))
}

// st may be nil for conn-level
func (sc *xhttp2serverConn) sendWindowUpdate32(st *xhttp2stream, n int32) {
	sc.serveG.check()
	if n == 0 {
		return
	}
	if n < 0 {
		panic("negative update")
	}
	var streamID uint32
	if st != nil {
		streamID = st.id
	}
	sc.writeFrame(xhttp2FrameWriteRequest{
		write:  xhttp2writeWindowUpdate{streamID: streamID, n: uint32(n)},
		stream: st,
	})
	var ok bool
	if st == nil {
		ok = sc.inflow.add(n)
	} else {
		ok = st.inflow.add(n)
	}
	if !ok {
		panic("internal error; sent too many window updates without decrements?")
	}
}

// requestBody is the Handler's Request.Body type.
// Read and Close may be called concurrently.
type xhttp2requestBody struct {
	stream        *xhttp2stream
	conn          *xhttp2serverConn
	closed        bool        // for use by Close only
	sawEOF        bool        // for use by Read only
	pipe          *xhttp2pipe // non-nil if we have a HTTP entity message body
	needsContinue bool        // need to send a 100-continue
}

func (b *xhttp2requestBody) Close() error {
	if b.pipe != nil && !b.closed {
		b.pipe.BreakWithError(xhttp2errClosedBody)
	}
	b.closed = true
	return nil
}

func (b *xhttp2requestBody) Read(p []byte) (n int, err error) {
	if b.needsContinue {
		b.needsContinue = false
		b.conn.write100ContinueHeaders(b.stream)
	}
	if b.pipe == nil || b.sawEOF {
		return 0, io.EOF
	}
	n, err = b.pipe.Read(p)
	if err == io.EOF {
		b.sawEOF = true
	}
	if b.conn == nil && xhttp2inTests {
		return
	}
	b.conn.noteBodyReadFromHandler(b.stream, n, err)
	return
}

// responseWriter is the http.ResponseWriter implementation.  It's
// intentionally small (1 pointer wide) to minimize garbage.  The
// responseWriterState pointer inside is zeroed at the end of a
// request (in handlerDone) and calls on the responseWriter thereafter
// simply crash (caller's mistake), but the much larger responseWriterState
// and buffers are reused between multiple requests.
type xhttp2responseWriter struct {
	rws *xhttp2responseWriterState
}

// Optional http.ResponseWriter interfaces implemented.
var (
	_ http.CloseNotifier = (*xhttp2responseWriter)(nil)
	_ http.Flusher       = (*xhttp2responseWriter)(nil)
	_ xhttp2stringWriter = (*xhttp2responseWriter)(nil)
)

type xhttp2responseWriterState struct {
	// immutable within a request:
	stream *xhttp2stream
	req    *http.Request
	body   *xhttp2requestBody // to close at end of request, if DATA frames didn't
	conn   *xhttp2serverConn

	// TODO: adjust buffer writing sizes based on server config, frame size updates from peer, etc
	bw *bufio.Writer // writing to a chunkWriter{this *responseWriterState}

	// mutated by http.Handler goroutine:
	handlerHeader http.Header // nil until called
	snapHeader    http.Header // snapshot of handlerHeader at WriteHeader time
	trailers      []string    // set in writeChunk
	status        int         // status code passed to WriteHeader
	wroteHeader   bool        // WriteHeader called (explicitly or implicitly). Not necessarily sent to user yet.
	sentHeader    bool        // have we sent the header frame?
	handlerDone   bool        // handler has finished

	sentContentLen int64 // non-zero if handler set a Content-Length header
	wroteBytes     int64

	closeNotifierMu sync.Mutex // guards closeNotifierCh
	closeNotifierCh chan bool  // nil until first used
}

type xhttp2chunkWriter struct{ rws *xhttp2responseWriterState }

func (cw xhttp2chunkWriter) Write(p []byte) (n int, err error) { return cw.rws.writeChunk(p) }

func (rws *xhttp2responseWriterState) hasTrailers() bool { return len(rws.trailers) != 0 }

// declareTrailer is called for each Trailer header when the
// response header is written. It notes that a header will need to be
// written in the trailers at the end of the response.
func (rws *xhttp2responseWriterState) declareTrailer(k string) {
	k = http.CanonicalHeaderKey(k)
	if !xhttp2ValidTrailerHeader(k) {

		rws.conn.logf("ignoring invalid trailer %q", k)
		return
	}
	if !xhttp2strSliceContains(rws.trailers, k) {
		rws.trailers = append(rws.trailers, k)
	}
}

// writeChunk writes chunks from the bufio.Writer. But because
// bufio.Writer may bypass its chunking, sometimes p may be
// arbitrarily large.
//
// writeChunk is also responsible (on the first chunk) for sending the
// HEADER response.
func (rws *xhttp2responseWriterState) writeChunk(p []byte) (n int, err error) {
	if !rws.wroteHeader {
		rws.writeHeader(200)
	}

	isHeadResp := rws.req.Method == "HEAD"
	if !rws.sentHeader {
		rws.sentHeader = true
		var ctype, clen string
		if clen = rws.snapHeader.Get("Content-Length"); clen != "" {
			rws.snapHeader.Del("Content-Length")
			clen64, err := strconv.ParseInt(clen, 10, 64)
			if err == nil && clen64 >= 0 {
				rws.sentContentLen = clen64
			} else {
				clen = ""
			}
		}
		if clen == "" && rws.handlerDone && xhttp2bodyAllowedForStatus(rws.status) && (len(p) > 0 || !isHeadResp) {
			clen = strconv.Itoa(len(p))
		}
		_, hasContentType := rws.snapHeader["Content-Type"]
		if !hasContentType && xhttp2bodyAllowedForStatus(rws.status) {
			ctype = http.DetectContentType(p)
		}
		var date string
		if _, ok := rws.snapHeader["Date"]; !ok {

			date = time.Now().UTC().Format(http.TimeFormat)
		}

		for _, v := range rws.snapHeader["Trailer"] {
			xhttp2foreachHeaderElement(v, rws.declareTrailer)
		}

		endStream := (rws.handlerDone && !rws.hasTrailers() && len(p) == 0) || isHeadResp
		err = rws.conn.writeHeaders(rws.stream, &xhttp2writeResHeaders{
			streamID:      rws.stream.id,
			httpResCode:   rws.status,
			h:             rws.snapHeader,
			endStream:     endStream,
			contentType:   ctype,
			contentLength: clen,
			date:          date,
		})
		if err != nil {
			return 0, err
		}
		if endStream {
			return 0, nil
		}
	}
	if isHeadResp {
		return len(p), nil
	}
	if len(p) == 0 && !rws.handlerDone {
		return 0, nil
	}

	if rws.handlerDone {
		rws.promoteUndeclaredTrailers()
	}

	endStream := rws.handlerDone && !rws.hasTrailers()
	if len(p) > 0 || endStream {

		if err := rws.conn.writeDataFromHandler(rws.stream, p, endStream); err != nil {
			return 0, err
		}
	}

	if rws.handlerDone && rws.hasTrailers() {
		err = rws.conn.writeHeaders(rws.stream, &xhttp2writeResHeaders{
			streamID:  rws.stream.id,
			h:         rws.handlerHeader,
			trailers:  rws.trailers,
			endStream: true,
		})
		return len(p), err
	}
	return len(p), nil
}

// TrailerPrefix is a magic prefix for ResponseWriter.Header map keys
// that, if present, signals that the map entry is actually for
// the response trailers, and not the response headers. The prefix
// is stripped after the ServeHTTP call finishes and the values are
// sent in the trailers.
//
// This mechanism is intended only for trailers that are not known
// prior to the headers being written. If the set of trailers is fixed
// or known before the header is written, the normal Go trailers mechanism
// is preferred:
//    https://golang.org/pkg/net/http/#ResponseWriter
//    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
const xhttp2TrailerPrefix = "Trailer:"

// promoteUndeclaredTrailers permits http.Handlers to set trailers
// after the header has already been flushed. Because the Go
// ResponseWriter interface has no way to set Trailers (only the
// Header), and because we didn't want to expand the ResponseWriter
// interface, and because nobody used trailers, and because RFC 2616
// says you SHOULD (but not must) predeclare any trailers in the
// header, the official ResponseWriter rules said trailers in Go must
// be predeclared, and then we reuse the same ResponseWriter.Header()
// map to mean both Headers and Trailers.  When it's time to write the
// Trailers, we pick out the fields of Headers that were declared as
// trailers. That worked for a while, until we found the first major
// user of Trailers in the wild: gRPC (using them only over http2),
// and gRPC libraries permit setting trailers mid-stream without
// predeclarnig them. So: change of plans. We still permit the old
// way, but we also permit this hack: if a Header() key begins with
// "Trailer:", the suffix of that key is a Trailer. Because ':' is an
// invalid token byte anyway, there is no ambiguity. (And it's already
// filtered out) It's mildly hacky, but not terrible.
//
// This method runs after the Handler is done and promotes any Header
// fields to be trailers.
func (rws *xhttp2responseWriterState) promoteUndeclaredTrailers() {
	for k, vv := range rws.handlerHeader {
		if !strings.HasPrefix(k, xhttp2TrailerPrefix) {
			continue
		}
		trailerKey := strings.TrimPrefix(k, xhttp2TrailerPrefix)
		rws.declareTrailer(trailerKey)
		rws.handlerHeader[http.CanonicalHeaderKey(trailerKey)] = vv
	}

	if len(rws.trailers) > 1 {
		sorter := xhttp2sorterPool.Get().(*xhttp2sorter)
		sorter.SortStrings(rws.trailers)
		xhttp2sorterPool.Put(sorter)
	}
}

func (w *xhttp2responseWriter) Flush() {
	rws := w.rws
	if rws == nil {
		panic("Header called after Handler finished")
	}
	if rws.bw.Buffered() > 0 {
		if err := rws.bw.Flush(); err != nil {

			return
		}
	} else {

		rws.writeChunk(nil)
	}
}

func (w *xhttp2responseWriter) CloseNotify() <-chan bool {
	rws := w.rws
	if rws == nil {
		panic("CloseNotify called after Handler finished")
	}
	rws.closeNotifierMu.Lock()
	ch := rws.closeNotifierCh
	if ch == nil {
		ch = make(chan bool, 1)
		rws.closeNotifierCh = ch
		cw := rws.stream.cw
		go func() {
			cw.Wait()
			ch <- true
		}()
	}
	rws.closeNotifierMu.Unlock()
	return ch
}

func (w *xhttp2responseWriter) Header() http.Header {
	rws := w.rws
	if rws == nil {
		panic("Header called after Handler finished")
	}
	if rws.handlerHeader == nil {
		rws.handlerHeader = make(http.Header)
	}
	return rws.handlerHeader
}

func (w *xhttp2responseWriter) WriteHeader(code int) {
	rws := w.rws
	if rws == nil {
		panic("WriteHeader called after Handler finished")
	}
	rws.writeHeader(code)
}

func (rws *xhttp2responseWriterState) writeHeader(code int) {
	if !rws.wroteHeader {
		rws.wroteHeader = true
		rws.status = code
		if len(rws.handlerHeader) > 0 {
			rws.snapHeader = xhttp2cloneHeader(rws.handlerHeader)
		}
	}
}

func xhttp2cloneHeader(h http.Header) http.Header {
	h2 := make(http.Header, len(h))
	for k, vv := range h {
		vv2 := make([]string, len(vv))
		copy(vv2, vv)
		h2[k] = vv2
	}
	return h2
}

// The Life Of A Write is like this:
//
// * Handler calls w.Write or w.WriteString ->
// * -> rws.bw (*bufio.Writer) ->
// * (Handler migth call Flush)
// * -> chunkWriter{rws}
// * -> responseWriterState.writeChunk(p []byte)
// * -> responseWriterState.writeChunk (most of the magic; see comment there)
func (w *xhttp2responseWriter) Write(p []byte) (n int, err error) {
	return w.write(len(p), p, "")
}

func (w *xhttp2responseWriter) WriteString(s string) (n int, err error) {
	return w.write(len(s), nil, s)
}

// either dataB or dataS is non-zero.
func (w *xhttp2responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error) {
	rws := w.rws
	if rws == nil {
		panic("Write called after Handler finished")
	}
	if !rws.wroteHeader {
		w.WriteHeader(200)
	}
	if !xhttp2bodyAllowedForStatus(rws.status) {
		return 0, http.ErrBodyNotAllowed
	}
	rws.wroteBytes += int64(len(dataB)) + int64(len(dataS))
	if rws.sentContentLen != 0 && rws.wroteBytes > rws.sentContentLen {

		return 0, errors.New("http2: handler wrote more than declared Content-Length")
	}

	if dataB != nil {
		return rws.bw.Write(dataB)
	} else {
		return rws.bw.WriteString(dataS)
	}
}

func (w *xhttp2responseWriter) handlerDone() {
	rws := w.rws
	rws.handlerDone = true
	w.Flush()
	w.rws = nil
	xhttp2responseWriterStatePool.Put(rws)
}

// Push errors.
var (
	xhttp2ErrRecursivePush    = errors.New("http2: recursive push not allowed")
	xhttp2ErrPushLimitReached = errors.New("http2: push would exceed peer's SETTINGS_MAX_CONCURRENT_STREAMS")
)

// pushOptions is the internal version of http.PushOptions, which we
// cannot include here because it's only defined in Go 1.8 and later.
type xhttp2pushOptions struct {
	Method string
	Header http.Header
}

func (w *xhttp2responseWriter) push(target string, opts xhttp2pushOptions) error {
	st := w.rws.stream
	sc := st.sc
	sc.serveG.checkNotOn()

	if st.isPushed() {
		return xhttp2ErrRecursivePush
	}

	if opts.Method == "" {
		opts.Method = "GET"
	}
	if opts.Header == nil {
		opts.Header = http.Header{}
	}
	wantScheme := "http"
	if w.rws.req.TLS != nil {
		wantScheme = "https"
	}

	u, err := url.Parse(target)
	if err != nil {
		return err
	}
	if u.Scheme == "" {
		if !strings.HasPrefix(target, "/") {
			return fmt.Errorf("target must be an absolute URL or an absolute path: %q", target)
		}
		u.Scheme = wantScheme
		u.Host = w.rws.req.Host
	} else {
		if u.Scheme != wantScheme {
			return fmt.Errorf("cannot push URL with scheme %q from request with scheme %q", u.Scheme, wantScheme)
		}
		if u.Host == "" {
			return errors.New("URL must have a host")
		}
	}
	for k := range opts.Header {
		if strings.HasPrefix(k, ":") {
			return fmt.Errorf("promised request headers cannot include pseudo header %q", k)
		}

		switch strings.ToLower(k) {
		case "content-length", "content-encoding", "trailer", "te", "expect", "host":
			return fmt.Errorf("promised request headers cannot include %q", k)
		}
	}
	if err := xhttp2checkValidHTTP2RequestHeaders(opts.Header); err != nil {
		return err
	}

	if opts.Method != "GET" && opts.Method != "HEAD" {
		return fmt.Errorf("method %q must be GET or HEAD", opts.Method)
	}

	msg := xhttp2startPushRequest{
		parent: st,
		method: opts.Method,
		url:    u,
		header: xhttp2cloneHeader(opts.Header),
		done:   xhttp2errChanPool.Get().(chan error),
	}

	select {
	case <-sc.doneServing:
		return xhttp2errClientDisconnected
	case <-st.cw:
		return xhttp2errStreamClosed
	case sc.wantStartPushCh <- msg:
	}

	select {
	case <-sc.doneServing:
		return xhttp2errClientDisconnected
	case <-st.cw:
		return xhttp2errStreamClosed
	case err := <-msg.done:
		xhttp2errChanPool.Put(msg.done)
		return err
	}
}

type xhttp2startPushRequest struct {
	parent *xhttp2stream
	method string
	url    *url.URL
	header http.Header
	done   chan error
}

func (sc *xhttp2serverConn) startPush(msg xhttp2startPushRequest) {
	sc.serveG.check()

	if msg.parent.state != xhttp2stateOpen && msg.parent.state != xhttp2stateHalfClosedRemote {

		msg.done <- xhttp2errStreamClosed
		return
	}

	if !sc.pushEnabled {
		msg.done <- http.ErrNotSupported
		return
	}

	allocatePromisedID := func() (uint32, error) {
		sc.serveG.check()

		if !sc.pushEnabled {
			return 0, http.ErrNotSupported
		}

		if sc.curPushedStreams+1 > sc.clientMaxStreams {
			return 0, xhttp2ErrPushLimitReached
		}

		if sc.maxPushPromiseID+2 >= 1<<31 {
			sc.startGracefulShutdown()
			return 0, xhttp2ErrPushLimitReached
		}
		sc.maxPushPromiseID += 2
		promisedID := sc.maxPushPromiseID

		promised := sc.newStream(promisedID, msg.parent.id, xhttp2stateHalfClosedRemote)
		rw, req, err := sc.newWriterAndRequestNoBody(promised, xhttp2requestParam{
			method:    msg.method,
			scheme:    msg.url.Scheme,
			authority: msg.url.Host,
			path:      msg.url.RequestURI(),
			header:    msg.header,
		})
		if err != nil {

			panic(fmt.Sprintf("newWriterAndRequestNoBody(%+v): %v", msg.url, err))
		}

		go sc.runHandler(rw, req, sc.handler.ServeHTTP)
		return promisedID, nil
	}

	sc.writeFrame(xhttp2FrameWriteRequest{
		write: &xhttp2writePushPromise{
			streamID:           msg.parent.id,
			method:             msg.method,
			url:                msg.url,
			h:                  msg.header,
			allocatePromisedID: allocatePromisedID,
		},
		stream: msg.parent,
		done:   msg.done,
	})
}

// foreachHeaderElement splits v according to the "#rule" construction
// in RFC 2616 section 2.1 and calls fn for each non-empty element.
func xhttp2foreachHeaderElement(v string, fn func(string)) {
	v = textproto.TrimString(v)
	if v == "" {
		return
	}
	if !strings.Contains(v, ",") {
		fn(v)
		return
	}
	for _, f := range strings.Split(v, ",") {
		if f = textproto.TrimString(f); f != "" {
			fn(f)
		}
	}
}

// From http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2
var xhttp2connHeaders = []string{
	"Connection",
	"Keep-Alive",
	"Proxy-Connection",
	"Transfer-Encoding",
	"Upgrade",
}

// checkValidHTTP2RequestHeaders checks whether h is a valid HTTP/2 request,
// per RFC 7540 Section 8.1.2.2.
// The returned error is reported to users.
func xhttp2checkValidHTTP2RequestHeaders(h http.Header) error {
	for _, k := range xhttp2connHeaders {
		if _, ok := h[k]; ok {
			return fmt.Errorf("request header %q is not valid in HTTP/2", k)
		}
	}
	te := h["Te"]
	if len(te) > 0 && (len(te) > 1 || (te[0] != "trailers" && te[0] != "")) {
		return errors.New(`request header "TE" may only be "trailers" in HTTP/2`)
	}
	return nil
}

func xhttp2new400Handler(err error) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		http.Error(w, err.Error(), http.StatusBadRequest)
	}
}

// ValidTrailerHeader reports whether name is a valid header field name to appear
// in trailers.
// See: http://tools.ietf.org/html/rfc7230#section-4.1.2
func xhttp2ValidTrailerHeader(name string) bool {
	name = http.CanonicalHeaderKey(name)
	if strings.HasPrefix(name, "If-") || xhttp2badTrailer[name] {
		return false
	}
	return true
}

var xhttp2badTrailer = map[string]bool{
	"Authorization":       true,
	"Cache-Control":       true,
	"Connection":          true,
	"Content-Encoding":    true,
	"Content-Length":      true,
	"Content-Range":       true,
	"Content-Type":        true,
	"Expect":              true,
	"Host":                true,
	"Keep-Alive":          true,
	"Max-Forwards":        true,
	"Pragma":              true,
	"Proxy-Authenticate":  true,
	"Proxy-Authorization": true,
	"Proxy-Connection":    true,
	"Range":               true,
	"Realm":               true,
	"Te":                  true,
	"Trailer":             true,
	"Transfer-Encoding":   true,
	"Www-Authenticate":    true,
}

// h1ServerShutdownChan returns a channel that will be closed when the
// provided *http.Server wants to shut down.
//
// This is a somewhat hacky way to get at http1 innards. It works
// when the http2 code is bundled into the net/http package in the
// standard library. The alternatives ended up making the cmd/go tool
// depend on http Servers. This is the lightest option for now.
// This is tested via the TestServeShutdown* tests in net/http.
func xhttp2h1ServerShutdownChan(hs *http.Server) <-chan struct{} {
	if fn := xhttp2testh1ServerShutdownChan; fn != nil {
		return fn(hs)
	}
	var x interface{} = hs
	type I interface {
		getDoneChan() <-chan struct{}
	}
	if hs, ok := x.(I); ok {
		return hs.getDoneChan()
	}
	return nil
}

// optional test hook for h1ServerShutdownChan.
var xhttp2testh1ServerShutdownChan func(hs *http.Server) <-chan struct{}

// h1ServerKeepAlivesDisabled reports whether hs has its keep-alives
// disabled. See comments on h1ServerShutdownChan above for why
// the code is written this way.
func xhttp2h1ServerKeepAlivesDisabled(hs *http.Server) bool {
	var x interface{} = hs
	type I interface {
		doKeepAlives() bool
	}
	if hs, ok := x.(I); ok {
		return !hs.doKeepAlives()
	}
	return false
}

const (
	// transportDefaultConnFlow is how many connection-level flow control
	// tokens we give the server at start-up, past the default 64k.
	xhttp2transportDefaultConnFlow = 1 << 30

	// transportDefaultStreamFlow is how many stream-level flow
	// control tokens we announce to the peer, and how many bytes
	// we buffer per stream.
	xhttp2transportDefaultStreamFlow = 4 << 20

	// transportDefaultStreamMinRefresh is the minimum number of bytes we'll send
	// a stream-level WINDOW_UPDATE for at a time.
	xhttp2transportDefaultStreamMinRefresh = 4 << 10

	xhttp2defaultUserAgent = "Go-http-client/2.0"
)

// Transport is an HTTP/2 Transport.
//
// A Transport internally caches connections to servers. It is safe
// for concurrent use by multiple goroutines.
type xhttp2Transport struct {
	// DialTLS specifies an optional dial function for creating
	// TLS connections for requests.
	//
	// If DialTLS is nil, tls.Dial is used.
	//
	// If the returned net.Conn has a ConnectionState method like tls.Conn,
	// it will be used to set http.Response.TLS.
	DialTLS func(network, addr string, cfg *tls.Config) (net.Conn, error)

	// TLSClientConfig specifies the TLS configuration to use with
	// tls.Client. If nil, the default configuration is used.
	TLSClientConfig *tls.Config

	// ConnPool optionally specifies an alternate connection pool to use.
	// If nil, the default is used.
	ConnPool xhttp2ClientConnPool

	// DisableCompression, if true, prevents the Transport from
	// requesting compression with an "Accept-Encoding: gzip"
	// request header when the Request contains no existing
	// Accept-Encoding value. If the Transport requests gzip on
	// its own and gets a gzipped response, it's transparently
	// decoded in the Response.Body. However, if the user
	// explicitly requested gzip it is not automatically
	// uncompressed.
	DisableCompression bool

	// AllowHTTP, if true, permits HTTP/2 requests using the insecure,
	// plain-text "http" scheme. Note that this does not enable h2c support.
	AllowHTTP bool

	// MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to
	// send in the initial settings frame. It is how many bytes
	// of response headers are allow. Unlike the http2 spec, zero here
	// means to use a default limit (currently 10MB). If you actually
	// want to advertise an ulimited value to the peer, Transport
	// interprets the highest possible value here (0xffffffff or 1<<32-1)
	// to mean no limit.
	MaxHeaderListSize uint32

	// t1, if non-nil, is the standard library Transport using
	// this transport. Its settings are used (but not its
	// RoundTrip method, etc).
	t1 *http.Transport

	connPoolOnce  sync.Once
	connPoolOrDef xhttp2ClientConnPool // non-nil version of ConnPool
}

func (t *xhttp2Transport) maxHeaderListSize() uint32 {
	if t.MaxHeaderListSize == 0 {
		return 10 << 20
	}
	if t.MaxHeaderListSize == 0xffffffff {
		return 0
	}
	return t.MaxHeaderListSize
}

func (t *xhttp2Transport) disableCompression() bool {
	return t.DisableCompression || (t.t1 != nil && t.t1.DisableCompression)
}

var xhttp2errTransportVersion = errors.New("http2: ConfigureTransport is only supported starting at Go 1.6")

// ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2.
// It requires Go 1.6 or later and returns an error if the net/http package is too old
// or if t1 has already been HTTP/2-enabled.
func xhttp2ConfigureTransport(t1 *http.Transport) error {
	_, err := xhttp2configureTransport(t1)
	return err
}

func (t *xhttp2Transport) connPool() xhttp2ClientConnPool {
	t.connPoolOnce.Do(t.initConnPool)
	return t.connPoolOrDef
}

func (t *xhttp2Transport) initConnPool() {
	if t.ConnPool != nil {
		t.connPoolOrDef = t.ConnPool
	} else {
		t.connPoolOrDef = &xhttp2clientConnPool{t: t}
	}
}

// ClientConn is the state of a single HTTP/2 client connection to an
// HTTP/2 server.
type xhttp2ClientConn struct {
	t         *xhttp2Transport
	tconn     net.Conn             // usually *tls.Conn, except specialized impls
	tlsState  *tls.ConnectionState // nil only for specialized impls
	singleUse bool                 // whether being used for a single http.Request

	// readLoop goroutine fields:
	readerDone chan struct{} // closed on error
	readerErr  error         // set before readerDone is closed

	idleTimeout time.Duration // or 0 for never
	idleTimer   *time.Timer

	mu              sync.Mutex // guards following
	cond            *sync.Cond // hold mu; broadcast on flow/closed changes
	flow            xhttp2flow // our conn-level flow control quota (cs.flow is per stream)
	inflow          xhttp2flow // peer's conn-level flow control
	closed          bool
	wantSettingsAck bool                           // we sent a SETTINGS frame and haven't heard back
	goAway          *xhttp2GoAwayFrame             // if non-nil, the GoAwayFrame we received
	goAwayDebug     string                         // goAway frame's debug data, retained as a string
	streams         map[uint32]*xhttp2clientStream // client-initiated
	nextStreamID    uint32
	pings           map[[8]byte]chan struct{} // in flight ping data to notification channel
	bw              *bufio.Writer
	br              *bufio.Reader
	fr              *xhttp2Framer
	lastActive      time.Time
	// Settings from peer: (also guarded by mu)
	maxFrameSize         uint32
	maxConcurrentStreams uint32
	initialWindowSize    uint32

	hbuf    bytes.Buffer // HPACK encoder writes into this
	henc    *hpack.Encoder
	freeBuf [][]byte

	wmu  sync.Mutex // held while writing; acquire AFTER mu if holding both
	werr error      // first write error that has occurred
}

// clientStream is the state for a single HTTP/2 stream. One of these
// is created for each Transport.RoundTrip call.
type xhttp2clientStream struct {
	cc            *xhttp2ClientConn
	req           *http.Request
	trace         *xhttp2clientTrace // or nil
	ID            uint32
	resc          chan xhttp2resAndError
	bufPipe       xhttp2pipe // buffered pipe with the flow-controlled response payload
	startedWrite  bool       // started request body write; guarded by cc.mu
	requestedGzip bool
	on100         func() // optional code to run if get a 100 continue response

	flow        xhttp2flow // guarded by cc.mu
	inflow      xhttp2flow // guarded by cc.mu
	bytesRemain int64      // -1 means unknown; owned by transportResponseBody.Read
	readErr     error      // sticky read error; owned by transportResponseBody.Read
	stopReqBody error      // if non-nil, stop writing req body; guarded by cc.mu
	didReset    bool       // whether we sent a RST_STREAM to the server; guarded by cc.mu

	peerReset chan struct{} // closed on peer reset
	resetErr  error         // populated before peerReset is closed

	done chan struct{} // closed when stream remove from cc.streams map; close calls guarded by cc.mu

	// owned by clientConnReadLoop:
	firstByte    bool // got the first response byte
	pastHeaders  bool // got first MetaHeadersFrame (actual headers)
	pastTrailers bool // got optional second MetaHeadersFrame (trailers)

	trailer    http.Header  // accumulated trailers
	resTrailer *http.Header // client's Response.Trailer
}

// awaitRequestCancel runs in its own goroutine and waits for the user
// to cancel a RoundTrip request, its context to expire, or for the
// request to be done (any way it might be removed from the cc.streams
// map: peer reset, successful completion, TCP connection breakage,
// etc)
func (cs *xhttp2clientStream) awaitRequestCancel(req *http.Request) {
	ctx := xhttp2reqContext(req)
	if req.Cancel == nil && ctx.Done() == nil {
		return
	}
	select {
	case <-req.Cancel:
		cs.cancelStream()
		cs.bufPipe.CloseWithError(xhttp2errRequestCanceled)
	case <-ctx.Done():
		cs.cancelStream()
		cs.bufPipe.CloseWithError(ctx.Err())
	case <-cs.done:
	}
}

func (cs *xhttp2clientStream) cancelStream() {
	cs.cc.mu.Lock()
	didReset := cs.didReset
	cs.didReset = true
	cs.cc.mu.Unlock()

	if !didReset {
		cs.cc.writeStreamReset(cs.ID, xhttp2ErrCodeCancel, nil)
	}
}

// checkResetOrDone reports any error sent in a RST_STREAM frame by the
// server, or errStreamClosed if the stream is complete.
func (cs *xhttp2clientStream) checkResetOrDone() error {
	select {
	case <-cs.peerReset:
		return cs.resetErr
	case <-cs.done:
		return xhttp2errStreamClosed
	default:
		return nil
	}
}

func (cs *xhttp2clientStream) abortRequestBodyWrite(err error) {
	if err == nil {
		panic("nil error")
	}
	cc := cs.cc
	cc.mu.Lock()
	cs.stopReqBody = err
	cc.cond.Broadcast()
	cc.mu.Unlock()
}

type xhttp2stickyErrWriter struct {
	w   io.Writer
	err *error
}

func (sew xhttp2stickyErrWriter) Write(p []byte) (n int, err error) {
	if *sew.err != nil {
		return 0, *sew.err
	}
	n, err = sew.w.Write(p)
	*sew.err = err
	return
}

var xhttp2ErrNoCachedConn = errors.New("http2: no cached connection was available")

// RoundTripOpt are options for the Transport.RoundTripOpt method.
type xhttp2RoundTripOpt struct {
	// OnlyCachedConn controls whether RoundTripOpt may
	// create a new TCP connection. If set true and
	// no cached connection is available, RoundTripOpt
	// will return ErrNoCachedConn.
	OnlyCachedConn bool
}

func (t *xhttp2Transport) RoundTrip(req *http.Request) (*http.Response, error) {
	return t.RoundTripOpt(req, xhttp2RoundTripOpt{})
}

// authorityAddr returns a given authority (a host/IP, or host:port / ip:port)
// and returns a host:port. The port 443 is added if needed.
func xhttp2authorityAddr(scheme string, authority string) (addr string) {
	host, port, err := net.SplitHostPort(authority)
	if err != nil {
		port = "443"
		if scheme == "http" {
			port = "80"
		}
		host = authority
	}
	if a, err := idna.ToASCII(host); err == nil {
		host = a
	}

	if strings.HasPrefix(host, "[") && strings.HasSuffix(host, "]") {
		return host + ":" + port
	}
	return net.JoinHostPort(host, port)
}

// RoundTripOpt is like RoundTrip, but takes options.
func (t *xhttp2Transport) RoundTripOpt(req *http.Request, opt xhttp2RoundTripOpt) (*http.Response, error) {
	if !(req.URL.Scheme == "https" || (req.URL.Scheme == "http" && t.AllowHTTP)) {
		return nil, errors.New("http2: unsupported scheme")
	}

	addr := xhttp2authorityAddr(req.URL.Scheme, req.URL.Host)
	for {
		cc, err := t.connPool().GetClientConn(req, addr)
		if err != nil {
			t.vlogf("http2: Transport failed to get client conn for %s: %v", addr, err)
			return nil, err
		}
		xhttp2traceGotConn(req, cc)
		res, err := cc.RoundTrip(req)
		if err != nil {
			if req, err = xhttp2shouldRetryRequest(req, err); err == nil {
				continue
			}
		}
		if err != nil {
			t.vlogf("RoundTrip failure: %v", err)
			return nil, err
		}
		return res, nil
	}
}

// CloseIdleConnections closes any connections which were previously
// connected from previous requests but are now sitting idle.
// It does not interrupt any connections currently in use.
func (t *xhttp2Transport) CloseIdleConnections() {
	if cp, ok := t.connPool().(xhttp2clientConnPoolIdleCloser); ok {
		cp.closeIdleConnections()
	}
}

var (
	xhttp2errClientConnClosed   = errors.New("http2: client conn is closed")
	xhttp2errClientConnUnusable = errors.New("http2: client conn not usable")

	xhttp2errClientConnGotGoAway                 = errors.New("http2: Transport received Server's graceful shutdown GOAWAY")
	xhttp2errClientConnGotGoAwayAfterSomeReqBody = errors.New("http2: Transport received Server's graceful shutdown GOAWAY; some request body already written")
)

// shouldRetryRequest is called by RoundTrip when a request fails to get
// response headers. It is always called with a non-nil error.
// It returns either a request to retry (either the same request, or a
// modified clone), or an error if the request can't be replayed.
func xhttp2shouldRetryRequest(req *http.Request, err error) (*http.Request, error) {
	switch err {
	default:
		return nil, err
	case xhttp2errClientConnUnusable, xhttp2errClientConnGotGoAway:
		return req, nil
	case xhttp2errClientConnGotGoAwayAfterSomeReqBody:

		if req.Body == nil || xhttp2reqBodyIsNoBody(req.Body) {
			return req, nil
		}

		getBody := xhttp2reqGetBody(req)
		if getBody == nil {
			return nil, errors.New("http2: Transport: peer server initiated graceful shutdown after some of Request.Body was written; define Request.GetBody to avoid this error")
		}
		body, err := getBody()
		if err != nil {
			return nil, err
		}
		newReq := *req
		newReq.Body = body
		return &newReq, nil
	}
}

func (t *xhttp2Transport) dialClientConn(addr string, singleUse bool) (*xhttp2ClientConn, error) {
	host, _, err := net.SplitHostPort(addr)
	if err != nil {
		return nil, err
	}
	tconn, err := t.dialTLS()("tcp", addr, t.newTLSConfig(host))
	if err != nil {
		return nil, err
	}
	return t.newClientConn(tconn, singleUse)
}

func (t *xhttp2Transport) newTLSConfig(host string) *tls.Config {
	cfg := new(tls.Config)
	if t.TLSClientConfig != nil {
		*cfg = *xhttp2cloneTLSConfig(t.TLSClientConfig)
	}
	if !xhttp2strSliceContains(cfg.NextProtos, xhttp2NextProtoTLS) {
		cfg.NextProtos = append([]string{xhttp2NextProtoTLS}, cfg.NextProtos...)
	}
	if cfg.ServerName == "" {
		cfg.ServerName = host
	}
	return cfg
}

func (t *xhttp2Transport) dialTLS() func(string, string, *tls.Config) (net.Conn, error) {
	if t.DialTLS != nil {
		return t.DialTLS
	}
	return t.dialTLSDefault
}

func (t *xhttp2Transport) dialTLSDefault(network, addr string, cfg *tls.Config) (net.Conn, error) {
	cn, err := tls.Dial(network, addr, cfg)
	if err != nil {
		return nil, err
	}
	if err := cn.Handshake(); err != nil {
		return nil, err
	}
	if !cfg.InsecureSkipVerify {
		if err := cn.VerifyHostname(cfg.ServerName); err != nil {
			return nil, err
		}
	}
	state := cn.ConnectionState()
	if p := state.NegotiatedProtocol; p != xhttp2NextProtoTLS {
		return nil, fmt.Errorf("http2: unexpected ALPN protocol %q; want %q", p, xhttp2NextProtoTLS)
	}
	if !state.NegotiatedProtocolIsMutual {
		return nil, errors.New("http2: could not negotiate protocol mutually")
	}
	return cn, nil
}

// disableKeepAlives reports whether connections should be closed as
// soon as possible after handling the first request.
func (t *xhttp2Transport) disableKeepAlives() bool {
	return t.t1 != nil && t.t1.DisableKeepAlives
}

func (t *xhttp2Transport) expectContinueTimeout() time.Duration {
	if t.t1 == nil {
		return 0
	}
	return xhttp2transportExpectContinueTimeout(t.t1)
}

func (t *xhttp2Transport) NewClientConn(c net.Conn) (*xhttp2ClientConn, error) {
	return t.newClientConn(c, false)
}

func (t *xhttp2Transport) newClientConn(c net.Conn, singleUse bool) (*xhttp2ClientConn, error) {
	cc := &xhttp2ClientConn{
		t:                    t,
		tconn:                c,
		readerDone:           make(chan struct{}),
		nextStreamID:         1,
		maxFrameSize:         16 << 10,
		initialWindowSize:    65535,
		maxConcurrentStreams: 1000,
		streams:              make(map[uint32]*xhttp2clientStream),
		singleUse:            singleUse,
		wantSettingsAck:      true,
		pings:                make(map[[8]byte]chan struct{}),
	}
	if d := t.idleConnTimeout(); d != 0 {
		cc.idleTimeout = d
		cc.idleTimer = time.AfterFunc(d, cc.onIdleTimeout)
	}
	if xhttp2VerboseLogs {
		t.vlogf("http2: Transport creating client conn %p to %v", cc, c.RemoteAddr())
	}

	cc.cond = sync.NewCond(&cc.mu)
	cc.flow.add(int32(xhttp2initialWindowSize))

	cc.bw = bufio.NewWriter(xhttp2stickyErrWriter{c, &cc.werr})
	cc.br = bufio.NewReader(c)
	cc.fr = xhttp2NewFramer(cc.bw, cc.br)
	cc.fr.ReadMetaHeaders = hpack.NewDecoder(xhttp2initialHeaderTableSize, nil)
	cc.fr.MaxHeaderListSize = t.maxHeaderListSize()

	cc.henc = hpack.NewEncoder(&cc.hbuf)

	if cs, ok := c.(xhttp2connectionStater); ok {
		state := cs.ConnectionState()
		cc.tlsState = &state
	}

	initialSettings := []xhttp2Setting{
		{ID: xhttp2SettingEnablePush, Val: 0},
		{ID: xhttp2SettingInitialWindowSize, Val: xhttp2transportDefaultStreamFlow},
	}
	if max := t.maxHeaderListSize(); max != 0 {
		initialSettings = append(initialSettings, xhttp2Setting{ID: xhttp2SettingMaxHeaderListSize, Val: max})
	}

	cc.bw.Write(xhttp2clientPreface)
	cc.fr.WriteSettings(initialSettings...)
	cc.fr.WriteWindowUpdate(0, xhttp2transportDefaultConnFlow)
	cc.inflow.add(xhttp2transportDefaultConnFlow + xhttp2initialWindowSize)
	cc.bw.Flush()
	if cc.werr != nil {
		return nil, cc.werr
	}

	go cc.readLoop()
	return cc, nil
}

func (cc *xhttp2ClientConn) setGoAway(f *xhttp2GoAwayFrame) {
	cc.mu.Lock()
	defer cc.mu.Unlock()

	old := cc.goAway
	cc.goAway = f

	if cc.goAwayDebug == "" {
		cc.goAwayDebug = string(f.DebugData())
	}
	if old != nil && old.ErrCode != xhttp2ErrCodeNo {
		cc.goAway.ErrCode = old.ErrCode
	}
	last := f.LastStreamID
	for streamID, cs := range cc.streams {
		if streamID > last {
			select {
			case cs.resc <- xhttp2resAndError{err: xhttp2errClientConnGotGoAway}:
			default:
			}
		}
	}
}

func (cc *xhttp2ClientConn) CanTakeNewRequest() bool {
	cc.mu.Lock()
	defer cc.mu.Unlock()
	return cc.canTakeNewRequestLocked()
}

func (cc *xhttp2ClientConn) canTakeNewRequestLocked() bool {
	if cc.singleUse && cc.nextStreamID > 1 {
		return false
	}
	return cc.goAway == nil && !cc.closed &&
		int64(len(cc.streams)+1) < int64(cc.maxConcurrentStreams) &&
		cc.nextStreamID < math.MaxInt32
}

// onIdleTimeout is called from a time.AfterFunc goroutine.  It will
// only be called when we're idle, but because we're coming from a new
// goroutine, there could be a new request coming in at the same time,
// so this simply calls the synchronized closeIfIdle to shut down this
// connection. The timer could just call closeIfIdle, but this is more
// clear.
func (cc *xhttp2ClientConn) onIdleTimeout() {
	cc.closeIfIdle()
}

func (cc *xhttp2ClientConn) closeIfIdle() {
	cc.mu.Lock()
	if len(cc.streams) > 0 {
		cc.mu.Unlock()
		return
	}
	cc.closed = true
	nextID := cc.nextStreamID

	cc.mu.Unlock()

	if xhttp2VerboseLogs {
		cc.vlogf("http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)", cc, cc.singleUse, nextID-2)
	}
	cc.tconn.Close()
}

const xhttp2maxAllocFrameSize = 512 << 10

// frameBuffer returns a scratch buffer suitable for writing DATA frames.
// They're capped at the min of the peer's max frame size or 512KB
// (kinda arbitrarily), but definitely capped so we don't allocate 4GB
// bufers.
func (cc *xhttp2ClientConn) frameScratchBuffer() []byte {
	cc.mu.Lock()
	size := cc.maxFrameSize
	if size > xhttp2maxAllocFrameSize {
		size = xhttp2maxAllocFrameSize
	}
	for i, buf := range cc.freeBuf {
		if len(buf) >= int(size) {
			cc.freeBuf[i] = nil
			cc.mu.Unlock()
			return buf[:size]
		}
	}
	cc.mu.Unlock()
	return make([]byte, size)
}

func (cc *xhttp2ClientConn) putFrameScratchBuffer(buf []byte) {
	cc.mu.Lock()
	defer cc.mu.Unlock()
	const maxBufs = 4 // arbitrary; 4 concurrent requests per conn? investigate.
	if len(cc.freeBuf) < maxBufs {
		cc.freeBuf = append(cc.freeBuf, buf)
		return
	}
	for i, old := range cc.freeBuf {
		if old == nil {
			cc.freeBuf[i] = buf
			return
		}
	}

}

// errRequestCanceled is a copy of net/http's errRequestCanceled because it's not
// exported. At least they'll be DeepEqual for h1-vs-h2 comparisons tests.
var xhttp2errRequestCanceled = errors.New("net/http: request canceled")

func xhttp2commaSeparatedTrailers(req *http.Request) (string, error) {
	keys := make([]string, 0, len(req.Trailer))
	for k := range req.Trailer {
		k = http.CanonicalHeaderKey(k)
		switch k {
		case "Transfer-Encoding", "Trailer", "Content-Length":
			return "", &xhttp2badStringError{"invalid Trailer key", k}
		}
		keys = append(keys, k)
	}
	if len(keys) > 0 {
		sort.Strings(keys)

		return strings.Join(keys, ","), nil
	}
	return "", nil
}

func (cc *xhttp2ClientConn) responseHeaderTimeout() time.Duration {
	if cc.t.t1 != nil {
		return cc.t.t1.ResponseHeaderTimeout
	}

	return 0
}

// checkConnHeaders checks whether req has any invalid connection-level headers.
// per RFC 7540 section 8.1.2.2: Connection-Specific Header Fields.
// Certain headers are special-cased as okay but not transmitted later.
func xhttp2checkConnHeaders(req *http.Request) error {
	if v := req.Header.Get("Upgrade"); v != "" {
		return fmt.Errorf("http2: invalid Upgrade request header: %q", req.Header["Upgrade"])
	}
	if vv := req.Header["Transfer-Encoding"]; len(vv) > 0 && (len(vv) > 1 || vv[0] != "" && vv[0] != "chunked") {
		return fmt.Errorf("http2: invalid Transfer-Encoding request header: %q", vv)
	}
	if vv := req.Header["Connection"]; len(vv) > 0 && (len(vv) > 1 || vv[0] != "" && vv[0] != "close" && vv[0] != "keep-alive") {
		return fmt.Errorf("http2: invalid Connection request header: %q", vv)
	}
	return nil
}

// actualContentLength returns a sanitized version of
// req.ContentLength, where 0 actually means zero (not unknown) and -1
// means unknown.
func xhttp2actualContentLength(req *http.Request) int64 {
	if req.Body == nil {
		return 0
	}
	if req.ContentLength != 0 {
		return req.ContentLength
	}
	return -1
}

func (cc *xhttp2ClientConn) RoundTrip(req *http.Request) (*http.Response, error) {
	if err := xhttp2checkConnHeaders(req); err != nil {
		return nil, err
	}
	if cc.idleTimer != nil {
		cc.idleTimer.Stop()
	}

	trailers, err := xhttp2commaSeparatedTrailers(req)
	if err != nil {
		return nil, err
	}
	hasTrailers := trailers != ""

	cc.mu.Lock()
	cc.lastActive = time.Now()
	if cc.closed || !cc.canTakeNewRequestLocked() {
		cc.mu.Unlock()
		return nil, xhttp2errClientConnUnusable
	}

	body := req.Body
	hasBody := body != nil
	contentLen := xhttp2actualContentLength(req)

	// TODO(bradfitz): this is a copy of the logic in net/http. Unify somewhere?
	var requestedGzip bool
	if !cc.t.disableCompression() &&
		req.Header.Get("Accept-Encoding") == "" &&
		req.Header.Get("Range") == "" &&
		req.Method != "HEAD" {

		requestedGzip = true
	}

	hdrs, err := cc.encodeHeaders(req, requestedGzip, trailers, contentLen)
	if err != nil {
		cc.mu.Unlock()
		return nil, err
	}

	cs := cc.newStream()
	cs.req = req
	cs.trace = xhttp2requestTrace(req)
	cs.requestedGzip = requestedGzip
	bodyWriter := cc.t.getBodyWriterState(cs, body)
	cs.on100 = bodyWriter.on100

	cc.wmu.Lock()
	endStream := !hasBody && !hasTrailers
	werr := cc.writeHeaders(cs.ID, endStream, hdrs)
	cc.wmu.Unlock()
	xhttp2traceWroteHeaders(cs.trace)
	cc.mu.Unlock()

	if werr != nil {
		if hasBody {
			req.Body.Close()
			bodyWriter.cancel()
		}
		cc.forgetStreamID(cs.ID)

		xhttp2traceWroteRequest(cs.trace, werr)
		return nil, werr
	}

	var respHeaderTimer <-chan time.Time
	if hasBody {
		bodyWriter.scheduleBodyWrite()
	} else {
		xhttp2traceWroteRequest(cs.trace, nil)
		if d := cc.responseHeaderTimeout(); d != 0 {
			timer := time.NewTimer(d)
			defer timer.Stop()
			respHeaderTimer = timer.C
		}
	}

	readLoopResCh := cs.resc
	bodyWritten := false
	ctx := xhttp2reqContext(req)

	handleReadLoopResponse := func(re xhttp2resAndError) (*http.Response, error) {
		res := re.res
		if re.err != nil || res.StatusCode > 299 {

			bodyWriter.cancel()
			cs.abortRequestBodyWrite(xhttp2errStopReqBodyWrite)
		}
		if re.err != nil {
			if re.err == xhttp2errClientConnGotGoAway {
				cc.mu.Lock()
				if cs.startedWrite {
					re.err = xhttp2errClientConnGotGoAwayAfterSomeReqBody
				}
				cc.mu.Unlock()
			}
			cc.forgetStreamID(cs.ID)
			return nil, re.err
		}
		res.Request = req
		res.TLS = cc.tlsState
		return res, nil
	}

	for {
		select {
		case re := <-readLoopResCh:
			return handleReadLoopResponse(re)
		case <-respHeaderTimer:
			cc.forgetStreamID(cs.ID)
			if !hasBody || bodyWritten {
				cc.writeStreamReset(cs.ID, xhttp2ErrCodeCancel, nil)
			} else {
				bodyWriter.cancel()
				cs.abortRequestBodyWrite(xhttp2errStopReqBodyWriteAndCancel)
			}
			return nil, xhttp2errTimeout
		case <-ctx.Done():
			cc.forgetStreamID(cs.ID)
			if !hasBody || bodyWritten {
				cc.writeStreamReset(cs.ID, xhttp2ErrCodeCancel, nil)
			} else {
				bodyWriter.cancel()
				cs.abortRequestBodyWrite(xhttp2errStopReqBodyWriteAndCancel)
			}
			return nil, ctx.Err()
		case <-req.Cancel:
			cc.forgetStreamID(cs.ID)
			if !hasBody || bodyWritten {
				cc.writeStreamReset(cs.ID, xhttp2ErrCodeCancel, nil)
			} else {
				bodyWriter.cancel()
				cs.abortRequestBodyWrite(xhttp2errStopReqBodyWriteAndCancel)
			}
			return nil, xhttp2errRequestCanceled
		case <-cs.peerReset:

			return nil, cs.resetErr
		case err := <-bodyWriter.resc:

			select {
			case re := <-readLoopResCh:
				return handleReadLoopResponse(re)
			default:
			}
			if err != nil {
				return nil, err
			}
			bodyWritten = true
			if d := cc.responseHeaderTimeout(); d != 0 {
				timer := time.NewTimer(d)
				defer timer.Stop()
				respHeaderTimer = timer.C
			}
		}
	}
}

// requires cc.wmu be held
func (cc *xhttp2ClientConn) writeHeaders(streamID uint32, endStream bool, hdrs []byte) error {
	first := true
	frameSize := int(cc.maxFrameSize)
	for len(hdrs) > 0 && cc.werr == nil {
		chunk := hdrs
		if len(chunk) > frameSize {
			chunk = chunk[:frameSize]
		}
		hdrs = hdrs[len(chunk):]
		endHeaders := len(hdrs) == 0
		if first {
			cc.fr.WriteHeaders(xhttp2HeadersFrameParam{
				StreamID:      streamID,
				BlockFragment: chunk,
				EndStream:     endStream,
				EndHeaders:    endHeaders,
			})
			first = false
		} else {
			cc.fr.WriteContinuation(streamID, endHeaders, chunk)
		}
	}

	cc.bw.Flush()
	return cc.werr
}

// internal error values; they don't escape to callers
var (
	// abort request body write; don't send cancel
	xhttp2errStopReqBodyWrite = errors.New("http2: aborting request body write")

	// abort request body write, but send stream reset of cancel.
	xhttp2errStopReqBodyWriteAndCancel = errors.New("http2: canceling request")
)

func (cs *xhttp2clientStream) writeRequestBody(body io.Reader, bodyCloser io.Closer) (err error) {
	cc := cs.cc
	sentEnd := false
	buf := cc.frameScratchBuffer()
	defer cc.putFrameScratchBuffer(buf)

	defer func() {
		xhttp2traceWroteRequest(cs.trace, err)

		cerr := bodyCloser.Close()
		if err == nil {
			err = cerr
		}
	}()

	req := cs.req
	hasTrailers := req.Trailer != nil

	var sawEOF bool
	for !sawEOF {
		n, err := body.Read(buf)
		if err == io.EOF {
			sawEOF = true
			err = nil
		} else if err != nil {
			return err
		}

		remain := buf[:n]
		for len(remain) > 0 && err == nil {
			var allowed int32
			allowed, err = cs.awaitFlowControl(len(remain))
			switch {
			case err == xhttp2errStopReqBodyWrite:
				return err
			case err == xhttp2errStopReqBodyWriteAndCancel:
				cc.writeStreamReset(cs.ID, xhttp2ErrCodeCancel, nil)
				return err
			case err != nil:
				return err
			}
			cc.wmu.Lock()
			data := remain[:allowed]
			remain = remain[allowed:]
			sentEnd = sawEOF && len(remain) == 0 && !hasTrailers
			err = cc.fr.WriteData(cs.ID, sentEnd, data)
			if err == nil {

				err = cc.bw.Flush()
			}
			cc.wmu.Unlock()
		}
		if err != nil {
			return err
		}
	}

	if sentEnd {

		return nil
	}

	var trls []byte
	if hasTrailers {
		cc.mu.Lock()
		defer cc.mu.Unlock()
		trls = cc.encodeTrailers(req)
	}

	cc.wmu.Lock()
	defer cc.wmu.Unlock()

	if len(trls) > 0 {
		err = cc.writeHeaders(cs.ID, true, trls)
	} else {
		err = cc.fr.WriteData(cs.ID, true, nil)
	}
	if ferr := cc.bw.Flush(); ferr != nil && err == nil {
		err = ferr
	}
	return err
}

// awaitFlowControl waits for [1, min(maxBytes, cc.cs.maxFrameSize)] flow
// control tokens from the server.
// It returns either the non-zero number of tokens taken or an error
// if the stream is dead.
func (cs *xhttp2clientStream) awaitFlowControl(maxBytes int) (taken int32, err error) {
	cc := cs.cc
	cc.mu.Lock()
	defer cc.mu.Unlock()
	for {
		if cc.closed {
			return 0, xhttp2errClientConnClosed
		}
		if cs.stopReqBody != nil {
			return 0, cs.stopReqBody
		}
		if err := cs.checkResetOrDone(); err != nil {
			return 0, err
		}
		if a := cs.flow.available(); a > 0 {
			take := a
			if int(take) > maxBytes {

				take = int32(maxBytes)
			}
			if take > int32(cc.maxFrameSize) {
				take = int32(cc.maxFrameSize)
			}
			cs.flow.take(take)
			return take, nil
		}
		cc.cond.Wait()
	}
}

type xhttp2badStringError struct {
	what string
	str  string
}

func (e *xhttp2badStringError) Error() string { return fmt.Sprintf("%s %q", e.what, e.str) }

// requires cc.mu be held.
func (cc *xhttp2ClientConn) encodeHeaders(req *http.Request, addGzipHeader bool, trailers string, contentLength int64) ([]byte, error) {
	cc.hbuf.Reset()

	host := req.Host
	if host == "" {
		host = req.URL.Host
	}
	host, err := httplex.PunycodeHostPort(host)
	if err != nil {
		return nil, err
	}

	var path string
	if req.Method != "CONNECT" {
		path = req.URL.RequestURI()
		if !xhttp2validPseudoPath(path) {
			orig := path
			path = strings.TrimPrefix(path, req.URL.Scheme+"://"+host)
			if !xhttp2validPseudoPath(path) {
				if req.URL.Opaque != "" {
					return nil, fmt.Errorf("invalid request :path %q from URL.Opaque = %q", orig, req.URL.Opaque)
				} else {
					return nil, fmt.Errorf("invalid request :path %q", orig)
				}
			}
		}
	}

	for k, vv := range req.Header {
		if !httplex.ValidHeaderFieldName(k) {
			return nil, fmt.Errorf("invalid HTTP header name %q", k)
		}
		for _, v := range vv {
			if !httplex.ValidHeaderFieldValue(v) {
				return nil, fmt.Errorf("invalid HTTP header value %q for header %q", v, k)
			}
		}
	}

	cc.writeHeader(":authority", host)
	cc.writeHeader(":method", req.Method)
	if req.Method != "CONNECT" {
		cc.writeHeader(":path", path)
		cc.writeHeader(":scheme", req.URL.Scheme)
	}
	if trailers != "" {
		cc.writeHeader("trailer", trailers)
	}

	var didUA bool
	for k, vv := range req.Header {
		lowKey := strings.ToLower(k)
		switch lowKey {
		case "host", "content-length":

			continue
		case "connection", "proxy-connection", "transfer-encoding", "upgrade", "keep-alive":

			continue
		case "user-agent":

			didUA = true
			if len(vv) < 1 {
				continue
			}
			vv = vv[:1]
			if vv[0] == "" {
				continue
			}
		}
		for _, v := range vv {
			cc.writeHeader(lowKey, v)
		}
	}
	if xhttp2shouldSendReqContentLength(req.Method, contentLength) {
		cc.writeHeader("content-length", strconv.FormatInt(contentLength, 10))
	}
	if addGzipHeader {
		cc.writeHeader("accept-encoding", "gzip")
	}
	if !didUA {
		cc.writeHeader("user-agent", xhttp2defaultUserAgent)
	}
	return cc.hbuf.Bytes(), nil
}

// shouldSendReqContentLength reports whether the http2.Transport should send
// a "content-length" request header. This logic is basically a copy of the net/http
// transferWriter.shouldSendContentLength.
// The contentLength is the corrected contentLength (so 0 means actually 0, not unknown).
// -1 means unknown.
func xhttp2shouldSendReqContentLength(method string, contentLength int64) bool {
	if contentLength > 0 {
		return true
	}
	if contentLength < 0 {
		return false
	}

	switch method {
	case "POST", "PUT", "PATCH":
		return true
	default:
		return false
	}
}

// requires cc.mu be held.
func (cc *xhttp2ClientConn) encodeTrailers(req *http.Request) []byte {
	cc.hbuf.Reset()
	for k, vv := range req.Trailer {

		lowKey := strings.ToLower(k)
		for _, v := range vv {
			cc.writeHeader(lowKey, v)
		}
	}
	return cc.hbuf.Bytes()
}

func (cc *xhttp2ClientConn) writeHeader(name, value string) {
	if xhttp2VerboseLogs {
		log.Printf("http2: Transport encoding header %q = %q", name, value)
	}
	cc.henc.WriteField(hpack.HeaderField{Name: name, Value: value})
}

type xhttp2resAndError struct {
	res *http.Response
	err error
}

// requires cc.mu be held.
func (cc *xhttp2ClientConn) newStream() *xhttp2clientStream {
	cs := &xhttp2clientStream{
		cc:        cc,
		ID:        cc.nextStreamID,
		resc:      make(chan xhttp2resAndError, 1),
		peerReset: make(chan struct{}),
		done:      make(chan struct{}),
	}
	cs.flow.add(int32(cc.initialWindowSize))
	cs.flow.setConnFlow(&cc.flow)
	cs.inflow.add(xhttp2transportDefaultStreamFlow)
	cs.inflow.setConnFlow(&cc.inflow)
	cc.nextStreamID += 2
	cc.streams[cs.ID] = cs
	return cs
}

func (cc *xhttp2ClientConn) forgetStreamID(id uint32) {
	cc.streamByID(id, true)
}

func (cc *xhttp2ClientConn) streamByID(id uint32, andRemove bool) *xhttp2clientStream {
	cc.mu.Lock()
	defer cc.mu.Unlock()
	cs := cc.streams[id]
	if andRemove && cs != nil && !cc.closed {
		cc.lastActive = time.Now()
		delete(cc.streams, id)
		if len(cc.streams) == 0 && cc.idleTimer != nil {
			cc.idleTimer.Reset(cc.idleTimeout)
		}
		close(cs.done)
		cc.cond.Broadcast()
	}
	return cs
}

// clientConnReadLoop is the state owned by the clientConn's frame-reading readLoop.
type xhttp2clientConnReadLoop struct {
	cc            *xhttp2ClientConn
	activeRes     map[uint32]*xhttp2clientStream // keyed by streamID
	closeWhenIdle bool
}

// readLoop runs in its own goroutine and reads and dispatches frames.
func (cc *xhttp2ClientConn) readLoop() {
	rl := &xhttp2clientConnReadLoop{
		cc:        cc,
		activeRes: make(map[uint32]*xhttp2clientStream),
	}

	defer rl.cleanup()
	cc.readerErr = rl.run()
	if ce, ok := cc.readerErr.(xhttp2ConnectionError); ok {
		cc.wmu.Lock()
		cc.fr.WriteGoAway(0, xhttp2ErrCode(ce), nil)
		cc.wmu.Unlock()
	}
}

// GoAwayError is returned by the Transport when the server closes the
// TCP connection after sending a GOAWAY frame.
type xhttp2GoAwayError struct {
	LastStreamID uint32
	ErrCode      xhttp2ErrCode
	DebugData    string
}

func (e xhttp2GoAwayError) Error() string {
	return fmt.Sprintf("http2: server sent GOAWAY and closed the connection; LastStreamID=%v, ErrCode=%v, debug=%q",
		e.LastStreamID, e.ErrCode, e.DebugData)
}

func xhttp2isEOFOrNetReadError(err error) bool {
	if err == io.EOF {
		return true
	}
	ne, ok := err.(*net.OpError)
	return ok && ne.Op == "read"
}

func (rl *xhttp2clientConnReadLoop) cleanup() {
	cc := rl.cc
	defer cc.tconn.Close()
	defer cc.t.connPool().MarkDead(cc)
	defer close(cc.readerDone)

	if cc.idleTimer != nil {
		cc.idleTimer.Stop()
	}

	err := cc.readerErr
	cc.mu.Lock()
	if cc.goAway != nil && xhttp2isEOFOrNetReadError(err) {
		err = xhttp2GoAwayError{
			LastStreamID: cc.goAway.LastStreamID,
			ErrCode:      cc.goAway.ErrCode,
			DebugData:    cc.goAwayDebug,
		}
	} else if err == io.EOF {
		err = io.ErrUnexpectedEOF
	}
	for _, cs := range rl.activeRes {
		cs.bufPipe.CloseWithError(err)
	}
	for _, cs := range cc.streams {
		select {
		case cs.resc <- xhttp2resAndError{err: err}:
		default:
		}
		close(cs.done)
	}
	cc.closed = true
	cc.cond.Broadcast()
	cc.mu.Unlock()
}

func (rl *xhttp2clientConnReadLoop) run() error {
	cc := rl.cc
	rl.closeWhenIdle = cc.t.disableKeepAlives() || cc.singleUse
	gotReply := false
	gotSettings := false
	for {
		f, err := cc.fr.ReadFrame()
		if err != nil {
			cc.vlogf("http2: Transport readFrame error on conn %p: (%T) %v", cc, err, err)
		}
		if se, ok := err.(xhttp2StreamError); ok {
			if cs := cc.streamByID(se.StreamID, true); cs != nil {
				cs.cc.writeStreamReset(cs.ID, se.Code, err)
				if se.Cause == nil {
					se.Cause = cc.fr.errDetail
				}
				rl.endStreamError(cs, se)
			}
			continue
		} else if err != nil {
			return err
		}
		if xhttp2VerboseLogs {
			cc.vlogf("http2: Transport received %s", xhttp2summarizeFrame(f))
		}
		if !gotSettings {
			if _, ok := f.(*xhttp2SettingsFrame); !ok {
				cc.logf("protocol error: received %T before a SETTINGS frame", f)
				return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
			}
			gotSettings = true
		}
		maybeIdle := false

		switch f := f.(type) {
		case *xhttp2MetaHeadersFrame:
			err = rl.processHeaders(f)
			maybeIdle = true
			gotReply = true
		case *xhttp2DataFrame:
			err = rl.processData(f)
			maybeIdle = true
		case *xhttp2GoAwayFrame:
			err = rl.processGoAway(f)
			maybeIdle = true
		case *xhttp2RSTStreamFrame:
			err = rl.processResetStream(f)
			maybeIdle = true
		case *xhttp2SettingsFrame:
			err = rl.processSettings(f)
		case *xhttp2PushPromiseFrame:
			err = rl.processPushPromise(f)
		case *xhttp2WindowUpdateFrame:
			err = rl.processWindowUpdate(f)
		case *xhttp2PingFrame:
			err = rl.processPing(f)
		default:
			cc.logf("Transport: unhandled response frame type %T", f)
		}
		if err != nil {
			if xhttp2VerboseLogs {
				cc.vlogf("http2: Transport conn %p received error from processing frame %v: %v", cc, xhttp2summarizeFrame(f), err)
			}
			return err
		}
		if rl.closeWhenIdle && gotReply && maybeIdle && len(rl.activeRes) == 0 {
			cc.closeIfIdle()
		}
	}
}

func (rl *xhttp2clientConnReadLoop) processHeaders(f *xhttp2MetaHeadersFrame) error {
	cc := rl.cc
	cs := cc.streamByID(f.StreamID, f.StreamEnded())
	if cs == nil {

		return nil
	}
	if !cs.firstByte {
		if cs.trace != nil {

			xhttp2traceFirstResponseByte(cs.trace)
		}
		cs.firstByte = true
	}
	if !cs.pastHeaders {
		cs.pastHeaders = true
	} else {
		return rl.processTrailers(cs, f)
	}

	res, err := rl.handleResponse(cs, f)
	if err != nil {
		if _, ok := err.(xhttp2ConnectionError); ok {
			return err
		}

		cs.cc.writeStreamReset(f.StreamID, xhttp2ErrCodeProtocol, err)
		cs.resc <- xhttp2resAndError{err: err}
		return nil
	}
	if res == nil {

		return nil
	}
	if res.Body != xhttp2noBody {
		rl.activeRes[cs.ID] = cs
	}
	cs.resTrailer = &res.Trailer
	cs.resc <- xhttp2resAndError{res: res}
	return nil
}

// may return error types nil, or ConnectionError. Any other error value
// is a StreamError of type ErrCodeProtocol. The returned error in that case
// is the detail.
//
// As a special case, handleResponse may return (nil, nil) to skip the
// frame (currently only used for 100 expect continue). This special
// case is going away after Issue 13851 is fixed.
func (rl *xhttp2clientConnReadLoop) handleResponse(cs *xhttp2clientStream, f *xhttp2MetaHeadersFrame) (*http.Response, error) {
	if f.Truncated {
		return nil, xhttp2errResponseHeaderListSize
	}

	status := f.PseudoValue("status")
	if status == "" {
		return nil, errors.New("missing status pseudo header")
	}
	statusCode, err := strconv.Atoi(status)
	if err != nil {
		return nil, errors.New("malformed non-numeric status pseudo header")
	}

	if statusCode == 100 {
		xhttp2traceGot100Continue(cs.trace)
		if cs.on100 != nil {
			cs.on100()
		}
		cs.pastHeaders = false
		return nil, nil
	}

	header := make(http.Header)
	res := &http.Response{
		Proto:      "HTTP/2.0",
		ProtoMajor: 2,
		Header:     header,
		StatusCode: statusCode,
		Status:     status + " " + http.StatusText(statusCode),
	}
	for _, hf := range f.RegularFields() {
		key := http.CanonicalHeaderKey(hf.Name)
		if key == "Trailer" {
			t := res.Trailer
			if t == nil {
				t = make(http.Header)
				res.Trailer = t
			}
			xhttp2foreachHeaderElement(hf.Value, func(v string) {
				t[http.CanonicalHeaderKey(v)] = nil
			})
		} else {
			header[key] = append(header[key], hf.Value)
		}
	}

	streamEnded := f.StreamEnded()
	isHead := cs.req.Method == "HEAD"
	if !streamEnded || isHead {
		res.ContentLength = -1
		if clens := res.Header["Content-Length"]; len(clens) == 1 {
			if clen64, err := strconv.ParseInt(clens[0], 10, 64); err == nil {
				res.ContentLength = clen64
			} else {

			}
		} else if len(clens) > 1 {

		}
	}

	if streamEnded || isHead {
		res.Body = xhttp2noBody
		return res, nil
	}

	buf := new(bytes.Buffer)
	cs.bufPipe = xhttp2pipe{b: buf}
	cs.bytesRemain = res.ContentLength
	res.Body = xhttp2transportResponseBody{cs}
	go cs.awaitRequestCancel(cs.req)

	if cs.requestedGzip && res.Header.Get("Content-Encoding") == "gzip" {
		res.Header.Del("Content-Encoding")
		res.Header.Del("Content-Length")
		res.ContentLength = -1
		res.Body = &xhttp2gzipReader{body: res.Body}
		xhttp2setResponseUncompressed(res)
	}
	return res, nil
}

func (rl *xhttp2clientConnReadLoop) processTrailers(cs *xhttp2clientStream, f *xhttp2MetaHeadersFrame) error {
	if cs.pastTrailers {

		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	cs.pastTrailers = true
	if !f.StreamEnded() {

		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}
	if len(f.PseudoFields()) > 0 {

		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}

	trailer := make(http.Header)
	for _, hf := range f.RegularFields() {
		key := http.CanonicalHeaderKey(hf.Name)
		trailer[key] = append(trailer[key], hf.Value)
	}
	cs.trailer = trailer

	rl.endStream(cs)
	return nil
}

// transportResponseBody is the concrete type of Transport.RoundTrip's
// Response.Body. It is an io.ReadCloser. On Read, it reads from cs.body.
// On Close it sends RST_STREAM if EOF wasn't already seen.
type xhttp2transportResponseBody struct {
	cs *xhttp2clientStream
}

func (b xhttp2transportResponseBody) Read(p []byte) (n int, err error) {
	cs := b.cs
	cc := cs.cc

	if cs.readErr != nil {
		return 0, cs.readErr
	}
	n, err = b.cs.bufPipe.Read(p)
	if cs.bytesRemain != -1 {
		if int64(n) > cs.bytesRemain {
			n = int(cs.bytesRemain)
			if err == nil {
				err = errors.New("net/http: server replied with more than declared Content-Length; truncated")
				cc.writeStreamReset(cs.ID, xhttp2ErrCodeProtocol, err)
			}
			cs.readErr = err
			return int(cs.bytesRemain), err
		}
		cs.bytesRemain -= int64(n)
		if err == io.EOF && cs.bytesRemain > 0 {
			err = io.ErrUnexpectedEOF
			cs.readErr = err
			return n, err
		}
	}
	if n == 0 {

		return
	}

	cc.mu.Lock()
	defer cc.mu.Unlock()

	var connAdd, streamAdd int32

	if v := cc.inflow.available(); v < xhttp2transportDefaultConnFlow/2 {
		connAdd = xhttp2transportDefaultConnFlow - v
		cc.inflow.add(connAdd)
	}
	if err == nil {

		v := int(cs.inflow.available()) + cs.bufPipe.Len()
		if v < xhttp2transportDefaultStreamFlow-xhttp2transportDefaultStreamMinRefresh {
			streamAdd = int32(xhttp2transportDefaultStreamFlow - v)
			cs.inflow.add(streamAdd)
		}
	}
	if connAdd != 0 || streamAdd != 0 {
		cc.wmu.Lock()
		defer cc.wmu.Unlock()
		if connAdd != 0 {
			cc.fr.WriteWindowUpdate(0, xhttp2mustUint31(connAdd))
		}
		if streamAdd != 0 {
			cc.fr.WriteWindowUpdate(cs.ID, xhttp2mustUint31(streamAdd))
		}
		cc.bw.Flush()
	}
	return
}

var xhttp2errClosedResponseBody = errors.New("http2: response body closed")

func (b xhttp2transportResponseBody) Close() error {
	cs := b.cs
	cc := cs.cc

	serverSentStreamEnd := cs.bufPipe.Err() == io.EOF
	unread := cs.bufPipe.Len()

	if unread > 0 || !serverSentStreamEnd {
		cc.mu.Lock()
		cc.wmu.Lock()
		if !serverSentStreamEnd {
			cc.fr.WriteRSTStream(cs.ID, xhttp2ErrCodeCancel)
		}

		if unread > 0 {
			cc.inflow.add(int32(unread))
			cc.fr.WriteWindowUpdate(0, uint32(unread))
		}
		cc.bw.Flush()
		cc.wmu.Unlock()
		cc.mu.Unlock()
	}

	cs.bufPipe.BreakWithError(xhttp2errClosedResponseBody)
	return nil
}

func (rl *xhttp2clientConnReadLoop) processData(f *xhttp2DataFrame) error {
	cc := rl.cc
	cs := cc.streamByID(f.StreamID, f.StreamEnded())
	data := f.Data()
	if cs == nil {
		cc.mu.Lock()
		neverSent := cc.nextStreamID
		cc.mu.Unlock()
		if f.StreamID >= neverSent {

			cc.logf("http2: Transport received unsolicited DATA frame; closing connection")
			return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
		}

		if f.Length > 0 {
			cc.mu.Lock()
			cc.inflow.add(int32(f.Length))
			cc.mu.Unlock()

			cc.wmu.Lock()
			cc.fr.WriteWindowUpdate(0, uint32(f.Length))
			cc.bw.Flush()
			cc.wmu.Unlock()
		}
		return nil
	}
	if f.Length > 0 {
		if len(data) > 0 && cs.bufPipe.b == nil {

			cc.logf("http2: Transport received DATA frame for closed stream; closing connection")
			return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
		}

		cc.mu.Lock()
		if cs.inflow.available() >= int32(f.Length) {
			cs.inflow.take(int32(f.Length))
		} else {
			cc.mu.Unlock()
			return xhttp2ConnectionError(xhttp2ErrCodeFlowControl)
		}

		if pad := int32(f.Length) - int32(len(data)); pad > 0 {
			cs.inflow.add(pad)
			cc.inflow.add(pad)
			cc.wmu.Lock()
			cc.fr.WriteWindowUpdate(0, uint32(pad))
			cc.fr.WriteWindowUpdate(cs.ID, uint32(pad))
			cc.bw.Flush()
			cc.wmu.Unlock()
		}
		didReset := cs.didReset
		cc.mu.Unlock()

		if len(data) > 0 && !didReset {
			if _, err := cs.bufPipe.Write(data); err != nil {
				rl.endStreamError(cs, err)
				return err
			}
		}
	}

	if f.StreamEnded() {
		rl.endStream(cs)
	}
	return nil
}

var xhttp2errInvalidTrailers = errors.New("http2: invalid trailers")

func (rl *xhttp2clientConnReadLoop) endStream(cs *xhttp2clientStream) {

	rl.endStreamError(cs, nil)
}

func (rl *xhttp2clientConnReadLoop) endStreamError(cs *xhttp2clientStream, err error) {
	var code func()
	if err == nil {
		err = io.EOF
		code = cs.copyTrailers
	}
	cs.bufPipe.closeWithErrorAndCode(err, code)
	delete(rl.activeRes, cs.ID)
	if xhttp2isConnectionCloseRequest(cs.req) {
		rl.closeWhenIdle = true
	}

	select {
	case cs.resc <- xhttp2resAndError{err: err}:
	default:
	}
}

func (cs *xhttp2clientStream) copyTrailers() {
	for k, vv := range cs.trailer {
		t := cs.resTrailer
		if *t == nil {
			*t = make(http.Header)
		}
		(*t)[k] = vv
	}
}

func (rl *xhttp2clientConnReadLoop) processGoAway(f *xhttp2GoAwayFrame) error {
	cc := rl.cc
	cc.t.connPool().MarkDead(cc)
	if f.ErrCode != 0 {

		cc.vlogf("transport got GOAWAY with error code = %v", f.ErrCode)
	}
	cc.setGoAway(f)
	return nil
}

func (rl *xhttp2clientConnReadLoop) processSettings(f *xhttp2SettingsFrame) error {
	cc := rl.cc
	cc.mu.Lock()
	defer cc.mu.Unlock()

	if f.IsAck() {
		if cc.wantSettingsAck {
			cc.wantSettingsAck = false
			return nil
		}
		return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
	}

	err := f.ForeachSetting(func(s xhttp2Setting) error {
		switch s.ID {
		case xhttp2SettingMaxFrameSize:
			cc.maxFrameSize = s.Val
		case xhttp2SettingMaxConcurrentStreams:
			cc.maxConcurrentStreams = s.Val
		case xhttp2SettingInitialWindowSize:

			if s.Val > math.MaxInt32 {
				return xhttp2ConnectionError(xhttp2ErrCodeFlowControl)
			}

			delta := int32(s.Val) - int32(cc.initialWindowSize)
			for _, cs := range cc.streams {
				cs.flow.add(delta)
			}
			cc.cond.Broadcast()

			cc.initialWindowSize = s.Val
		default:

			cc.vlogf("Unhandled Setting: %v", s)
		}
		return nil
	})
	if err != nil {
		return err
	}

	cc.wmu.Lock()
	defer cc.wmu.Unlock()

	cc.fr.WriteSettingsAck()
	cc.bw.Flush()
	return cc.werr
}

func (rl *xhttp2clientConnReadLoop) processWindowUpdate(f *xhttp2WindowUpdateFrame) error {
	cc := rl.cc
	cs := cc.streamByID(f.StreamID, false)
	if f.StreamID != 0 && cs == nil {
		return nil
	}

	cc.mu.Lock()
	defer cc.mu.Unlock()

	fl := &cc.flow
	if cs != nil {
		fl = &cs.flow
	}
	if !fl.add(int32(f.Increment)) {
		return xhttp2ConnectionError(xhttp2ErrCodeFlowControl)
	}
	cc.cond.Broadcast()
	return nil
}

func (rl *xhttp2clientConnReadLoop) processResetStream(f *xhttp2RSTStreamFrame) error {
	cs := rl.cc.streamByID(f.StreamID, true)
	if cs == nil {

		return nil
	}
	select {
	case <-cs.peerReset:

	default:
		err := xhttp2streamError(cs.ID, f.ErrCode)
		cs.resetErr = err
		close(cs.peerReset)
		cs.bufPipe.CloseWithError(err)
		cs.cc.cond.Broadcast()
	}
	delete(rl.activeRes, cs.ID)
	return nil
}

// Ping sends a PING frame to the server and waits for the ack.
// Public implementation is in go17.go and not_go17.go
func (cc *xhttp2ClientConn) ping(ctx xhttp2contextContext) error {
	c := make(chan struct{})
	// Generate a random payload
	var p [8]byte
	for {
		if _, err := rand.Read(p[:]); err != nil {
			return err
		}
		cc.mu.Lock()

		if _, found := cc.pings[p]; !found {
			cc.pings[p] = c
			cc.mu.Unlock()
			break
		}
		cc.mu.Unlock()
	}
	cc.wmu.Lock()
	if err := cc.fr.WritePing(false, p); err != nil {
		cc.wmu.Unlock()
		return err
	}
	if err := cc.bw.Flush(); err != nil {
		cc.wmu.Unlock()
		return err
	}
	cc.wmu.Unlock()
	select {
	case <-c:
		return nil
	case <-ctx.Done():
		return ctx.Err()
	case <-cc.readerDone:

		return cc.readerErr
	}
}

func (rl *xhttp2clientConnReadLoop) processPing(f *xhttp2PingFrame) error {
	if f.IsAck() {
		cc := rl.cc
		cc.mu.Lock()
		defer cc.mu.Unlock()

		if c, ok := cc.pings[f.Data]; ok {
			close(c)
			delete(cc.pings, f.Data)
		}
		return nil
	}
	cc := rl.cc
	cc.wmu.Lock()
	defer cc.wmu.Unlock()
	if err := cc.fr.WritePing(true, f.Data); err != nil {
		return err
	}
	return cc.bw.Flush()
}

func (rl *xhttp2clientConnReadLoop) processPushPromise(f *xhttp2PushPromiseFrame) error {

	return xhttp2ConnectionError(xhttp2ErrCodeProtocol)
}

func (cc *xhttp2ClientConn) writeStreamReset(streamID uint32, code xhttp2ErrCode, err error) {

	cc.wmu.Lock()
	cc.fr.WriteRSTStream(streamID, code)
	cc.bw.Flush()
	cc.wmu.Unlock()
}

var (
	xhttp2errResponseHeaderListSize = errors.New("http2: response header list larger than advertised limit")
	xhttp2errPseudoTrailers         = errors.New("http2: invalid pseudo header in trailers")
)

func (cc *xhttp2ClientConn) logf(format string, args ...interface{}) {
	cc.t.logf(format, args...)
}

func (cc *xhttp2ClientConn) vlogf(format string, args ...interface{}) {
	cc.t.vlogf(format, args...)
}

func (t *xhttp2Transport) vlogf(format string, args ...interface{}) {
	if xhttp2VerboseLogs {
		t.logf(format, args...)
	}
}

func (t *xhttp2Transport) logf(format string, args ...interface{}) {
	log.Printf(format, args...)
}

var xhttp2noBody io.ReadCloser = ioutil.NopCloser(bytes.NewReader(nil))

func xhttp2strSliceContains(ss []string, s string) bool {
	for _, v := range ss {
		if v == s {
			return true
		}
	}
	return false
}

type xhttp2erringRoundTripper struct{ err error }

func (rt xhttp2erringRoundTripper) RoundTrip(*http.Request) (*http.Response, error) {
	return nil, rt.err
}

// gzipReader wraps a response body so it can lazily
// call gzip.NewReader on the first call to Read
type xhttp2gzipReader struct {
	body io.ReadCloser // underlying Response.Body
	zr   *gzip.Reader  // lazily-initialized gzip reader
	zerr error         // sticky error
}

func (gz *xhttp2gzipReader) Read(p []byte) (n int, err error) {
	if gz.zerr != nil {
		return 0, gz.zerr
	}
	if gz.zr == nil {
		gz.zr, err = gzip.NewReader(gz.body)
		if err != nil {
			gz.zerr = err
			return 0, err
		}
	}
	return gz.zr.Read(p)
}

func (gz *xhttp2gzipReader) Close() error {
	return gz.body.Close()
}

type xhttp2errorReader struct{ err error }

func (r xhttp2errorReader) Read(p []byte) (int, error) { return 0, r.err }

// bodyWriterState encapsulates various state around the Transport's writing
// of the request body, particularly regarding doing delayed writes of the body
// when the request contains "Expect: 100-continue".
type xhttp2bodyWriterState struct {
	cs     *xhttp2clientStream
	timer  *time.Timer   // if non-nil, we're doing a delayed write
	fnonce *sync.Once    // to call fn with
	fn     func()        // the code to run in the goroutine, writing the body
	resc   chan error    // result of fn's execution
	delay  time.Duration // how long we should delay a delayed write for
}

func (t *xhttp2Transport) getBodyWriterState(cs *xhttp2clientStream, body io.Reader) (s xhttp2bodyWriterState) {
	s.cs = cs
	if body == nil {
		return
	}
	resc := make(chan error, 1)
	s.resc = resc
	s.fn = func() {
		cs.cc.mu.Lock()
		cs.startedWrite = true
		cs.cc.mu.Unlock()
		resc <- cs.writeRequestBody(body, cs.req.Body)
	}
	s.delay = t.expectContinueTimeout()
	if s.delay == 0 ||
		!httplex.HeaderValuesContainsToken(
			cs.req.Header["Expect"],
			"100-continue") {
		return
	}
	s.fnonce = new(sync.Once)

	// Arm the timer with a very large duration, which we'll
	// intentionally lower later. It has to be large now because
	// we need a handle to it before writing the headers, but the
	// s.delay value is defined to not start until after the
	// request headers were written.
	const hugeDuration = 365 * 24 * time.Hour
	s.timer = time.AfterFunc(hugeDuration, func() {
		s.fnonce.Do(s.fn)
	})
	return
}

func (s xhttp2bodyWriterState) cancel() {
	if s.timer != nil {
		s.timer.Stop()
	}
}

func (s xhttp2bodyWriterState) on100() {
	if s.timer == nil {

		return
	}
	s.timer.Stop()
	go func() { s.fnonce.Do(s.fn) }()
}

// scheduleBodyWrite starts writing the body, either immediately (in
// the common case) or after the delay timeout. It should not be
// called until after the headers have been written.
func (s xhttp2bodyWriterState) scheduleBodyWrite() {
	if s.timer == nil {

		go s.fn()
		return
	}
	xhttp2traceWait100Continue(s.cs.trace)
	if s.timer.Stop() {
		s.timer.Reset(s.delay)
	}
}

// isConnectionCloseRequest reports whether req should use its own
// connection for a single request and then close the connection.
func xhttp2isConnectionCloseRequest(req *http.Request) bool {
	return req.Close || httplex.HeaderValuesContainsToken(req.Header["Connection"], "close")
}

// writeFramer is implemented by any type that is used to write frames.
type xhttp2writeFramer interface {
	writeFrame(xhttp2writeContext) error

	// staysWithinBuffer reports whether this writer promises that
	// it will only write less than or equal to size bytes, and it
	// won't Flush the write context.
	staysWithinBuffer(size int) bool
}

// writeContext is the interface needed by the various frame writer
// types below. All the writeFrame methods below are scheduled via the
// frame writing scheduler (see writeScheduler in writesched.go).
//
// This interface is implemented by *serverConn.
//
// TODO: decide whether to a) use this in the client code (which didn't
// end up using this yet, because it has a simpler design, not
// currently implementing priorities), or b) delete this and
// make the server code a bit more concrete.
type xhttp2writeContext interface {
	Framer() *xhttp2Framer
	Flush() error
	CloseConn() error
	// HeaderEncoder returns an HPACK encoder that writes to the
	// returned buffer.
	HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)
}

// endsStream reports whether the given frame writer w will locally
// close the stream.
func xhttp2endsStream(w xhttp2writeFramer) bool {
	switch v := w.(type) {
	case *xhttp2writeData:
		return v.endStream
	case *xhttp2writeResHeaders:
		return v.endStream
	case nil:

		panic("endsStream called on nil writeFramer")
	}
	return false
}

type xhttp2flushFrameWriter struct{}

func (xhttp2flushFrameWriter) writeFrame(ctx xhttp2writeContext) error {
	return ctx.Flush()
}

func (xhttp2flushFrameWriter) staysWithinBuffer(max int) bool { return false }

type xhttp2writeSettings []xhttp2Setting

func (s xhttp2writeSettings) staysWithinBuffer(max int) bool {
	const settingSize = 6 // uint16 + uint32
	return xhttp2frameHeaderLen+settingSize*len(s) <= max

}

func (s xhttp2writeSettings) writeFrame(ctx xhttp2writeContext) error {
	return ctx.Framer().WriteSettings([]xhttp2Setting(s)...)
}

type xhttp2writeGoAway struct {
	maxStreamID uint32
	code        xhttp2ErrCode
}

func (p *xhttp2writeGoAway) writeFrame(ctx xhttp2writeContext) error {
	err := ctx.Framer().WriteGoAway(p.maxStreamID, p.code, nil)
	if p.code != 0 {
		ctx.Flush()
		time.Sleep(50 * time.Millisecond)
		ctx.CloseConn()
	}
	return err
}

func (*xhttp2writeGoAway) staysWithinBuffer(max int) bool { return false }

type xhttp2writeData struct {
	streamID  uint32
	p         []byte
	endStream bool
}

func (w *xhttp2writeData) String() string {
	return fmt.Sprintf("writeData(stream=%d, p=%d, endStream=%v)", w.streamID, len(w.p), w.endStream)
}

func (w *xhttp2writeData) writeFrame(ctx xhttp2writeContext) error {
	return ctx.Framer().WriteData(w.streamID, w.endStream, w.p)
}

func (w *xhttp2writeData) staysWithinBuffer(max int) bool {
	return xhttp2frameHeaderLen+len(w.p) <= max
}

// handlerPanicRST is the message sent from handler goroutines when
// the handler panics.
type xhttp2handlerPanicRST struct {
	StreamID uint32
}

func (hp xhttp2handlerPanicRST) writeFrame(ctx xhttp2writeContext) error {
	return ctx.Framer().WriteRSTStream(hp.StreamID, xhttp2ErrCodeInternal)
}

func (hp xhttp2handlerPanicRST) staysWithinBuffer(max int) bool { return xhttp2frameHeaderLen+4 <= max }

func (se xhttp2StreamError) writeFrame(ctx xhttp2writeContext) error {
	return ctx.Framer().WriteRSTStream(se.StreamID, se.Code)
}

func (se xhttp2StreamError) staysWithinBuffer(max int) bool { return xhttp2frameHeaderLen+4 <= max }

type xhttp2writePingAck struct{ pf *xhttp2PingFrame }

func (w xhttp2writePingAck) writeFrame(ctx xhttp2writeContext) error {
	return ctx.Framer().WritePing(true, w.pf.Data)
}

func (w xhttp2writePingAck) staysWithinBuffer(max int) bool {
	return xhttp2frameHeaderLen+len(w.pf.Data) <= max
}

type xhttp2writeSettingsAck struct{}

func (xhttp2writeSettingsAck) writeFrame(ctx xhttp2writeContext) error {
	return ctx.Framer().WriteSettingsAck()
}

func (xhttp2writeSettingsAck) staysWithinBuffer(max int) bool { return xhttp2frameHeaderLen <= max }

// splitHeaderBlock splits headerBlock into fragments so that each fragment fits
// in a single frame, then calls fn for each fragment. firstFrag/lastFrag are true
// for the first/last fragment, respectively.
func xhttp2splitHeaderBlock(ctx xhttp2writeContext, headerBlock []byte, fn func(ctx xhttp2writeContext, frag []byte, firstFrag, lastFrag bool) error) error {
	// For now we're lazy and just pick the minimum MAX_FRAME_SIZE
	// that all peers must support (16KB). Later we could care
	// more and send larger frames if the peer advertised it, but
	// there's little point. Most headers are small anyway (so we
	// generally won't have CONTINUATION frames), and extra frames
	// only waste 9 bytes anyway.
	const maxFrameSize = 16384

	first := true
	for len(headerBlock) > 0 {
		frag := headerBlock
		if len(frag) > maxFrameSize {
			frag = frag[:maxFrameSize]
		}
		headerBlock = headerBlock[len(frag):]
		if err := fn(ctx, frag, first, len(headerBlock) == 0); err != nil {
			return err
		}
		first = false
	}
	return nil
}

// writeResHeaders is a request to write a HEADERS and 0+ CONTINUATION frames
// for HTTP response headers or trailers from a server handler.
type xhttp2writeResHeaders struct {
	streamID    uint32
	httpResCode int         // 0 means no ":status" line
	h           http.Header // may be nil
	trailers    []string    // if non-nil, which keys of h to write. nil means all.
	endStream   bool

	date          string
	contentType   string
	contentLength string
}

func xhttp2encKV(enc *hpack.Encoder, k, v string) {
	if xhttp2VerboseLogs {
		log.Printf("http2: server encoding header %q = %q", k, v)
	}
	enc.WriteField(hpack.HeaderField{Name: k, Value: v})
}

func (w *xhttp2writeResHeaders) staysWithinBuffer(max int) bool {

	return false
}

func (w *xhttp2writeResHeaders) writeFrame(ctx xhttp2writeContext) error {
	enc, buf := ctx.HeaderEncoder()
	buf.Reset()

	if w.httpResCode != 0 {
		xhttp2encKV(enc, ":status", xhttp2httpCodeString(w.httpResCode))
	}

	xhttp2encodeHeaders(enc, w.h, w.trailers)

	if w.contentType != "" {
		xhttp2encKV(enc, "content-type", w.contentType)
	}
	if w.contentLength != "" {
		xhttp2encKV(enc, "content-length", w.contentLength)
	}
	if w.date != "" {
		xhttp2encKV(enc, "date", w.date)
	}

	headerBlock := buf.Bytes()
	if len(headerBlock) == 0 && w.trailers == nil {
		panic("unexpected empty hpack")
	}

	return xhttp2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)
}

func (w *xhttp2writeResHeaders) writeHeaderBlock(ctx xhttp2writeContext, frag []byte, firstFrag, lastFrag bool) error {
	if firstFrag {
		return ctx.Framer().WriteHeaders(xhttp2HeadersFrameParam{
			StreamID:      w.streamID,
			BlockFragment: frag,
			EndStream:     w.endStream,
			EndHeaders:    lastFrag,
		})
	} else {
		return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)
	}
}

// writePushPromise is a request to write a PUSH_PROMISE and 0+ CONTINUATION frames.
type xhttp2writePushPromise struct {
	streamID uint32   // pusher stream
	method   string   // for :method
	url      *url.URL // for :scheme, :authority, :path
	h        http.Header

	// Creates an ID for a pushed stream. This runs on serveG just before
	// the frame is written. The returned ID is copied to promisedID.
	allocatePromisedID func() (uint32, error)
	promisedID         uint32
}

func (w *xhttp2writePushPromise) staysWithinBuffer(max int) bool {

	return false
}

func (w *xhttp2writePushPromise) writeFrame(ctx xhttp2writeContext) error {
	enc, buf := ctx.HeaderEncoder()
	buf.Reset()

	xhttp2encKV(enc, ":method", w.method)
	xhttp2encKV(enc, ":scheme", w.url.Scheme)
	xhttp2encKV(enc, ":authority", w.url.Host)
	xhttp2encKV(enc, ":path", w.url.RequestURI())
	xhttp2encodeHeaders(enc, w.h, nil)

	headerBlock := buf.Bytes()
	if len(headerBlock) == 0 {
		panic("unexpected empty hpack")
	}

	return xhttp2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)
}

func (w *xhttp2writePushPromise) writeHeaderBlock(ctx xhttp2writeContext, frag []byte, firstFrag, lastFrag bool) error {
	if firstFrag {
		return ctx.Framer().WritePushPromise(xhttp2PushPromiseParam{
			StreamID:      w.streamID,
			PromiseID:     w.promisedID,
			BlockFragment: frag,
			EndHeaders:    lastFrag,
		})
	} else {
		return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)
	}
}

type xhttp2write100ContinueHeadersFrame struct {
	streamID uint32
}

func (w xhttp2write100ContinueHeadersFrame) writeFrame(ctx xhttp2writeContext) error {
	enc, buf := ctx.HeaderEncoder()
	buf.Reset()
	xhttp2encKV(enc, ":status", "100")
	return ctx.Framer().WriteHeaders(xhttp2HeadersFrameParam{
		StreamID:      w.streamID,
		BlockFragment: buf.Bytes(),
		EndStream:     false,
		EndHeaders:    true,
	})
}

func (w xhttp2write100ContinueHeadersFrame) staysWithinBuffer(max int) bool {

	return 9+2*(len(":status")+len("100")) <= max
}

type xhttp2writeWindowUpdate struct {
	streamID uint32 // or 0 for conn-level
	n        uint32
}

func (wu xhttp2writeWindowUpdate) staysWithinBuffer(max int) bool {
	return xhttp2frameHeaderLen+4 <= max
}

func (wu xhttp2writeWindowUpdate) writeFrame(ctx xhttp2writeContext) error {
	return ctx.Framer().WriteWindowUpdate(wu.streamID, wu.n)
}

// encodeHeaders encodes an http.Header. If keys is not nil, then (k, h[k])
// is encoded only only if k is in keys.
func xhttp2encodeHeaders(enc *hpack.Encoder, h http.Header, keys []string) {
	if keys == nil {
		sorter := xhttp2sorterPool.Get().(*xhttp2sorter)

		defer xhttp2sorterPool.Put(sorter)
		keys = sorter.Keys(h)
	}
	for _, k := range keys {
		vv := h[k]
		k = xhttp2lowerHeader(k)
		if !xhttp2validWireHeaderFieldName(k) {

			continue
		}
		isTE := k == "transfer-encoding"
		for _, v := range vv {
			if !httplex.ValidHeaderFieldValue(v) {

				continue
			}

			if isTE && v != "trailers" {
				continue
			}
			xhttp2encKV(enc, k, v)
		}
	}
}

// WriteScheduler is the interface implemented by HTTP/2 write schedulers.
// Methods are never called concurrently.
type xhttp2WriteScheduler interface {
	// OpenStream opens a new stream in the write scheduler.
	// It is illegal to call this with streamID=0 or with a streamID that is
	// already open -- the call may panic.
	OpenStream(streamID uint32, options xhttp2OpenStreamOptions)

	// CloseStream closes a stream in the write scheduler. Any frames queued on
	// this stream should be discarded. It is illegal to call this on a stream
	// that is not open -- the call may panic.
	CloseStream(streamID uint32)

	// AdjustStream adjusts the priority of the given stream. This may be called
	// on a stream that has not yet been opened or has been closed. Note that
	// RFC 7540 allows PRIORITY frames to be sent on streams in any state. See:
	// https://tools.ietf.org/html/rfc7540#section-5.1
	AdjustStream(streamID uint32, priority xhttp2PriorityParam)

	// Push queues a frame in the scheduler. In most cases, this will not be
	// called with wr.StreamID()!=0 unless that stream is currently open. The one
	// exception is RST_STREAM frames, which may be sent on idle or closed streams.
	Push(wr xhttp2FrameWriteRequest)

	// Pop dequeues the next frame to write. Returns false if no frames can
	// be written. Frames with a given wr.StreamID() are Pop'd in the same
	// order they are Push'd.
	Pop() (wr xhttp2FrameWriteRequest, ok bool)
}

// OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.
type xhttp2OpenStreamOptions struct {
	// PusherID is zero if the stream was initiated by the client. Otherwise,
	// PusherID names the stream that pushed the newly opened stream.
	PusherID uint32
}

// FrameWriteRequest is a request to write a frame.
type xhttp2FrameWriteRequest struct {
	// write is the interface value that does the writing, once the
	// WriteScheduler has selected this frame to write. The write
	// functions are all defined in write.go.
	write xhttp2writeFramer

	// stream is the stream on which this frame will be written.
	// nil for non-stream frames like PING and SETTINGS.
	stream *xhttp2stream

	// done, if non-nil, must be a buffered channel with space for
	// 1 message and is sent the return value from write (or an
	// earlier error) when the frame has been written.
	done chan error
}

// StreamID returns the id of the stream this frame will be written to.
// 0 is used for non-stream frames such as PING and SETTINGS.
func (wr xhttp2FrameWriteRequest) StreamID() uint32 {
	if wr.stream == nil {
		if se, ok := wr.write.(xhttp2StreamError); ok {

			return se.StreamID
		}
		return 0
	}
	return wr.stream.id
}

// DataSize returns the number of flow control bytes that must be consumed
// to write this entire frame. This is 0 for non-DATA frames.
func (wr xhttp2FrameWriteRequest) DataSize() int {
	if wd, ok := wr.write.(*xhttp2writeData); ok {
		return len(wd.p)
	}
	return 0
}

// Consume consumes min(n, available) bytes from this frame, where available
// is the number of flow control bytes available on the stream. Consume returns
// 0, 1, or 2 frames, where the integer return value gives the number of frames
// returned.
//
// If flow control prevents consuming any bytes, this returns (_, _, 0). If
// the entire frame was consumed, this returns (wr, _, 1). Otherwise, this
// returns (consumed, rest, 2), where 'consumed' contains the consumed bytes and
// 'rest' contains the remaining bytes. The consumed bytes are deducted from the
// underlying stream's flow control budget.
func (wr xhttp2FrameWriteRequest) Consume(n int32) (xhttp2FrameWriteRequest, xhttp2FrameWriteRequest, int) {
	var empty xhttp2FrameWriteRequest

	wd, ok := wr.write.(*xhttp2writeData)
	if !ok || len(wd.p) == 0 {
		return wr, empty, 1
	}

	allowed := wr.stream.flow.available()
	if n < allowed {
		allowed = n
	}
	if wr.stream.sc.maxFrameSize < allowed {
		allowed = wr.stream.sc.maxFrameSize
	}
	if allowed <= 0 {
		return empty, empty, 0
	}
	if len(wd.p) > int(allowed) {
		wr.stream.flow.take(allowed)
		consumed := xhttp2FrameWriteRequest{
			stream: wr.stream,
			write: &xhttp2writeData{
				streamID: wd.streamID,
				p:        wd.p[:allowed],

				endStream: false,
			},

			done: nil,
		}
		rest := xhttp2FrameWriteRequest{
			stream: wr.stream,
			write: &xhttp2writeData{
				streamID:  wd.streamID,
				p:         wd.p[allowed:],
				endStream: wd.endStream,
			},
			done: wr.done,
		}
		return consumed, rest, 2
	}

	wr.stream.flow.take(int32(len(wd.p)))
	return wr, empty, 1
}

// String is for debugging only.
func (wr xhttp2FrameWriteRequest) String() string {
	var des string
	if s, ok := wr.write.(fmt.Stringer); ok {
		des = s.String()
	} else {
		des = fmt.Sprintf("%T", wr.write)
	}
	return fmt.Sprintf("[FrameWriteRequest stream=%d, ch=%v, writer=%v]", wr.StreamID(), wr.done != nil, des)
}

// writeQueue is used by implementations of WriteScheduler.
type xhttp2writeQueue struct {
	s []xhttp2FrameWriteRequest
}

func (q *xhttp2writeQueue) empty() bool { return len(q.s) == 0 }

func (q *xhttp2writeQueue) push(wr xhttp2FrameWriteRequest) {
	q.s = append(q.s, wr)
}

func (q *xhttp2writeQueue) shift() xhttp2FrameWriteRequest {
	if len(q.s) == 0 {
		panic("invalid use of queue")
	}
	wr := q.s[0]

	copy(q.s, q.s[1:])
	q.s[len(q.s)-1] = xhttp2FrameWriteRequest{}
	q.s = q.s[:len(q.s)-1]
	return wr
}

// consume consumes up to n bytes from q.s[0]. If the frame is
// entirely consumed, it is removed from the queue. If the frame
// is partially consumed, the frame is kept with the consumed
// bytes removed. Returns true iff any bytes were consumed.
func (q *xhttp2writeQueue) consume(n int32) (xhttp2FrameWriteRequest, bool) {
	if len(q.s) == 0 {
		return xhttp2FrameWriteRequest{}, false
	}
	consumed, rest, numresult := q.s[0].Consume(n)
	switch numresult {
	case 0:
		return xhttp2FrameWriteRequest{}, false
	case 1:
		q.shift()
	case 2:
		q.s[0] = rest
	}
	return consumed, true
}

type xhttp2writeQueuePool []*xhttp2writeQueue

// put inserts an unused writeQueue into the pool.
func (p *xhttp2writeQueuePool) put(q *xhttp2writeQueue) {
	for i := range q.s {
		q.s[i] = xhttp2FrameWriteRequest{}
	}
	q.s = q.s[:0]
	*p = append(*p, q)
}

// get returns an empty writeQueue.
func (p *xhttp2writeQueuePool) get() *xhttp2writeQueue {
	ln := len(*p)
	if ln == 0 {
		return new(xhttp2writeQueue)
	}
	x := ln - 1
	q := (*p)[x]
	(*p)[x] = nil
	*p = (*p)[:x]
	return q
}

// RFC 7540, Section 5.3.5: the default weight is 16.
const xhttp2priorityDefaultWeight = 15 // 16 = 15 + 1

// PriorityWriteSchedulerConfig configures a priorityWriteScheduler.
type xhttp2PriorityWriteSchedulerConfig struct {
	// MaxClosedNodesInTree controls the maximum number of closed streams to
	// retain in the priority tree. Setting this to zero saves a small amount
	// of memory at the cost of performance.
	//
	// See RFC 7540, Section 5.3.4:
	//   "It is possible for a stream to become closed while prioritization
	//   information ... is in transit. ... This potentially creates suboptimal
	//   prioritization, since the stream could be given a priority that is
	//   different from what is intended. To avoid these problems, an endpoint
	//   SHOULD retain stream prioritization state for a period after streams
	//   become closed. The longer state is retained, the lower the chance that
	//   streams are assigned incorrect or default priority values."
	MaxClosedNodesInTree int

	// MaxIdleNodesInTree controls the maximum number of idle streams to
	// retain in the priority tree. Setting this to zero saves a small amount
	// of memory at the cost of performance.
	//
	// See RFC 7540, Section 5.3.4:
	//   Similarly, streams that are in the "idle" state can be assigned
	//   priority or become a parent of other streams. This allows for the
	//   creation of a grouping node in the dependency tree, which enables
	//   more flexible expressions of priority. Idle streams begin with a
	//   default priority (Section 5.3.5).
	MaxIdleNodesInTree int

	// ThrottleOutOfOrderWrites enables write throttling to help ensure that
	// data is delivered in priority order. This works around a race where
	// stream B depends on stream A and both streams are about to call Write
	// to queue DATA frames. If B wins the race, a naive scheduler would eagerly
	// write as much data from B as possible, but this is suboptimal because A
	// is a higher-priority stream. With throttling enabled, we write a small
	// amount of data from B to minimize the amount of bandwidth that B can
	// steal from A.
	ThrottleOutOfOrderWrites bool
}

// NewPriorityWriteScheduler constructs a WriteScheduler that schedules
// frames by following HTTP/2 priorities as described in RFC 7340 Section 5.3.
// If cfg is nil, default options are used.
func xhttp2NewPriorityWriteScheduler(cfg *xhttp2PriorityWriteSchedulerConfig) xhttp2WriteScheduler {
	if cfg == nil {

		cfg = &xhttp2PriorityWriteSchedulerConfig{
			MaxClosedNodesInTree:     10,
			MaxIdleNodesInTree:       10,
			ThrottleOutOfOrderWrites: false,
		}
	}

	ws := &xhttp2priorityWriteScheduler{
		nodes:                make(map[uint32]*xhttp2priorityNode),
		maxClosedNodesInTree: cfg.MaxClosedNodesInTree,
		maxIdleNodesInTree:   cfg.MaxIdleNodesInTree,
		enableWriteThrottle:  cfg.ThrottleOutOfOrderWrites,
	}
	ws.nodes[0] = &ws.root
	if cfg.ThrottleOutOfOrderWrites {
		ws.writeThrottleLimit = 1024
	} else {
		ws.writeThrottleLimit = math.MaxInt32
	}
	return ws
}

type xhttp2priorityNodeState int

const (
	xhttp2priorityNodeOpen xhttp2priorityNodeState = iota
	xhttp2priorityNodeClosed
	xhttp2priorityNodeIdle
)

// priorityNode is a node in an HTTP/2 priority tree.
// Each node is associated with a single stream ID.
// See RFC 7540, Section 5.3.
type xhttp2priorityNode struct {
	q            xhttp2writeQueue        // queue of pending frames to write
	id           uint32                  // id of the stream, or 0 for the root of the tree
	weight       uint8                   // the actual weight is weight+1, so the value is in [1,256]
	state        xhttp2priorityNodeState // open | closed | idle
	bytes        int64                   // number of bytes written by this node, or 0 if closed
	subtreeBytes int64                   // sum(node.bytes) of all nodes in this subtree

	// These links form the priority tree.
	parent     *xhttp2priorityNode
	kids       *xhttp2priorityNode // start of the kids list
	prev, next *xhttp2priorityNode // doubly-linked list of siblings
}

func (n *xhttp2priorityNode) setParent(parent *xhttp2priorityNode) {
	if n == parent {
		panic("setParent to self")
	}
	if n.parent == parent {
		return
	}

	if parent := n.parent; parent != nil {
		if n.prev == nil {
			parent.kids = n.next
		} else {
			n.prev.next = n.next
		}
		if n.next != nil {
			n.next.prev = n.prev
		}
	}

	n.parent = parent
	if parent == nil {
		n.next = nil
		n.prev = nil
	} else {
		n.next = parent.kids
		n.prev = nil
		if n.next != nil {
			n.next.prev = n
		}
		parent.kids = n
	}
}

func (n *xhttp2priorityNode) addBytes(b int64) {
	n.bytes += b
	for ; n != nil; n = n.parent {
		n.subtreeBytes += b
	}
}

// walkReadyInOrder iterates over the tree in priority order, calling f for each node
// with a non-empty write queue. When f returns true, this funcion returns true and the
// walk halts. tmp is used as scratch space for sorting.
//
// f(n, openParent) takes two arguments: the node to visit, n, and a bool that is true
// if any ancestor p of n is still open (ignoring the root node).
func (n *xhttp2priorityNode) walkReadyInOrder(openParent bool, tmp *[]*xhttp2priorityNode, f func(*xhttp2priorityNode, bool) bool) bool {
	if !n.q.empty() && f(n, openParent) {
		return true
	}
	if n.kids == nil {
		return false
	}

	if n.id != 0 {
		openParent = openParent || (n.state == xhttp2priorityNodeOpen)
	}

	w := n.kids.weight
	needSort := false
	for k := n.kids.next; k != nil; k = k.next {
		if k.weight != w {
			needSort = true
			break
		}
	}
	if !needSort {
		for k := n.kids; k != nil; k = k.next {
			if k.walkReadyInOrder(openParent, tmp, f) {
				return true
			}
		}
		return false
	}

	*tmp = (*tmp)[:0]
	for n.kids != nil {
		*tmp = append(*tmp, n.kids)
		n.kids.setParent(nil)
	}
	sort.Sort(xhttp2sortPriorityNodeSiblings(*tmp))
	for i := len(*tmp) - 1; i >= 0; i-- {
		(*tmp)[i].setParent(n)
	}
	for k := n.kids; k != nil; k = k.next {
		if k.walkReadyInOrder(openParent, tmp, f) {
			return true
		}
	}
	return false
}

type xhttp2sortPriorityNodeSiblings []*xhttp2priorityNode

func (z xhttp2sortPriorityNodeSiblings) Len() int { return len(z) }

func (z xhttp2sortPriorityNodeSiblings) Swap(i, k int) { z[i], z[k] = z[k], z[i] }

func (z xhttp2sortPriorityNodeSiblings) Less(i, k int) bool {

	wi, bi := float64(z[i].weight+1), float64(z[i].subtreeBytes)
	wk, bk := float64(z[k].weight+1), float64(z[k].subtreeBytes)
	if bi == 0 && bk == 0 {
		return wi >= wk
	}
	if bk == 0 {
		return false
	}
	return bi/bk <= wi/wk
}

type xhttp2priorityWriteScheduler struct {
	// root is the root of the priority tree, where root.id = 0.
	// The root queues control frames that are not associated with any stream.
	root xhttp2priorityNode

	// nodes maps stream ids to priority tree nodes.
	nodes map[uint32]*xhttp2priorityNode

	// maxID is the maximum stream id in nodes.
	maxID uint32

	// lists of nodes that have been closed or are idle, but are kept in
	// the tree for improved prioritization. When the lengths exceed either
	// maxClosedNodesInTree or maxIdleNodesInTree, old nodes are discarded.
	closedNodes, idleNodes []*xhttp2priorityNode

	// From the config.
	maxClosedNodesInTree int
	maxIdleNodesInTree   int
	writeThrottleLimit   int32
	enableWriteThrottle  bool

	// tmp is scratch space for priorityNode.walkReadyInOrder to reduce allocations.
	tmp []*xhttp2priorityNode

	// pool of empty queues for reuse.
	queuePool xhttp2writeQueuePool
}

func (ws *xhttp2priorityWriteScheduler) OpenStream(streamID uint32, options xhttp2OpenStreamOptions) {

	if curr := ws.nodes[streamID]; curr != nil {
		if curr.state != xhttp2priorityNodeIdle {
			panic(fmt.Sprintf("stream %d already opened", streamID))
		}
		curr.state = xhttp2priorityNodeOpen
		return
	}

	parent := ws.nodes[options.PusherID]
	if parent == nil {
		parent = &ws.root
	}
	n := &xhttp2priorityNode{
		q:      *ws.queuePool.get(),
		id:     streamID,
		weight: xhttp2priorityDefaultWeight,
		state:  xhttp2priorityNodeOpen,
	}
	n.setParent(parent)
	ws.nodes[streamID] = n
	if streamID > ws.maxID {
		ws.maxID = streamID
	}
}

func (ws *xhttp2priorityWriteScheduler) CloseStream(streamID uint32) {
	if streamID == 0 {
		panic("violation of WriteScheduler interface: cannot close stream 0")
	}
	if ws.nodes[streamID] == nil {
		panic(fmt.Sprintf("violation of WriteScheduler interface: unknown stream %d", streamID))
	}
	if ws.nodes[streamID].state != xhttp2priorityNodeOpen {
		panic(fmt.Sprintf("violation of WriteScheduler interface: stream %d already closed", streamID))
	}

	n := ws.nodes[streamID]
	n.state = xhttp2priorityNodeClosed
	n.addBytes(-n.bytes)

	q := n.q
	ws.queuePool.put(&q)
	n.q.s = nil
	if ws.maxClosedNodesInTree > 0 {
		ws.addClosedOrIdleNode(&ws.closedNodes, ws.maxClosedNodesInTree, n)
	} else {
		ws.removeNode(n)
	}
}

func (ws *xhttp2priorityWriteScheduler) AdjustStream(streamID uint32, priority xhttp2PriorityParam) {
	if streamID == 0 {
		panic("adjustPriority on root")
	}

	n := ws.nodes[streamID]
	if n == nil {
		if streamID <= ws.maxID || ws.maxIdleNodesInTree == 0 {
			return
		}
		ws.maxID = streamID
		n = &xhttp2priorityNode{
			q:      *ws.queuePool.get(),
			id:     streamID,
			weight: xhttp2priorityDefaultWeight,
			state:  xhttp2priorityNodeIdle,
		}
		n.setParent(&ws.root)
		ws.nodes[streamID] = n
		ws.addClosedOrIdleNode(&ws.idleNodes, ws.maxIdleNodesInTree, n)
	}

	parent := ws.nodes[priority.StreamDep]
	if parent == nil {
		n.setParent(&ws.root)
		n.weight = xhttp2priorityDefaultWeight
		return
	}

	if n == parent {
		return
	}

	for x := parent.parent; x != nil; x = x.parent {
		if x == n {
			parent.setParent(n.parent)
			break
		}
	}

	if priority.Exclusive {
		k := parent.kids
		for k != nil {
			next := k.next
			if k != n {
				k.setParent(n)
			}
			k = next
		}
	}

	n.setParent(parent)
	n.weight = priority.Weight
}

func (ws *xhttp2priorityWriteScheduler) Push(wr xhttp2FrameWriteRequest) {
	var n *xhttp2priorityNode
	if id := wr.StreamID(); id == 0 {
		n = &ws.root
	} else {
		n = ws.nodes[id]
		if n == nil {

			if wr.DataSize() > 0 {
				panic("add DATA on non-open stream")
			}
			n = &ws.root
		}
	}
	n.q.push(wr)
}

func (ws *xhttp2priorityWriteScheduler) Pop() (wr xhttp2FrameWriteRequest, ok bool) {
	ws.root.walkReadyInOrder(false, &ws.tmp, func(n *xhttp2priorityNode, openParent bool) bool {
		limit := int32(math.MaxInt32)
		if openParent {
			limit = ws.writeThrottleLimit
		}
		wr, ok = n.q.consume(limit)
		if !ok {
			return false
		}
		n.addBytes(int64(wr.DataSize()))

		if openParent {
			ws.writeThrottleLimit += 1024
			if ws.writeThrottleLimit < 0 {
				ws.writeThrottleLimit = math.MaxInt32
			}
		} else if ws.enableWriteThrottle {
			ws.writeThrottleLimit = 1024
		}
		return true
	})
	return wr, ok
}

func (ws *xhttp2priorityWriteScheduler) addClosedOrIdleNode(list *[]*xhttp2priorityNode, maxSize int, n *xhttp2priorityNode) {
	if maxSize == 0 {
		return
	}
	if len(*list) == maxSize {

		ws.removeNode((*list)[0])
		x := (*list)[1:]
		copy(*list, x)
		*list = (*list)[:len(x)]
	}
	*list = append(*list, n)
}

func (ws *xhttp2priorityWriteScheduler) removeNode(n *xhttp2priorityNode) {
	for k := n.kids; k != nil; k = k.next {
		k.setParent(n.parent)
	}
	n.setParent(nil)
	delete(ws.nodes, n.id)
}

// NewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2
// priorities. Control frames like SETTINGS and PING are written before DATA
// frames, but if no control frames are queued and multiple streams have queued
// HEADERS or DATA frames, Pop selects a ready stream arbitrarily.
func xhttp2NewRandomWriteScheduler() xhttp2WriteScheduler {
	return &xhttp2randomWriteScheduler{sq: make(map[uint32]*xhttp2writeQueue)}
}

type xhttp2randomWriteScheduler struct {
	// zero are frames not associated with a specific stream.
	zero xhttp2writeQueue

	// sq contains the stream-specific queues, keyed by stream ID.
	// When a stream is idle or closed, it's deleted from the map.
	sq map[uint32]*xhttp2writeQueue

	// pool of empty queues for reuse.
	queuePool xhttp2writeQueuePool
}

func (ws *xhttp2randomWriteScheduler) OpenStream(streamID uint32, options xhttp2OpenStreamOptions) {

}

func (ws *xhttp2randomWriteScheduler) CloseStream(streamID uint32) {
	q, ok := ws.sq[streamID]
	if !ok {
		return
	}
	delete(ws.sq, streamID)
	ws.queuePool.put(q)
}

func (ws *xhttp2randomWriteScheduler) AdjustStream(streamID uint32, priority xhttp2PriorityParam) {

}

func (ws *xhttp2randomWriteScheduler) Push(wr xhttp2FrameWriteRequest) {
	id := wr.StreamID()
	if id == 0 {
		ws.zero.push(wr)
		return
	}
	q, ok := ws.sq[id]
	if !ok {
		q = ws.queuePool.get()
		ws.sq[id] = q
	}
	q.push(wr)
}

func (ws *xhttp2randomWriteScheduler) Pop() (xhttp2FrameWriteRequest, bool) {

	if !ws.zero.empty() {
		return ws.zero.shift(), true
	}

	for _, q := range ws.sq {
		if wr, ok := q.consume(math.MaxInt32); ok {
			return wr, true
		}
	}
	return xhttp2FrameWriteRequest{}, false
}
